partial(func, <em>args, </em><em>kwargs)              возвращает новую функцию, которая является копией исходной функции func, 
                                            но с некоторыми аргументами, переданными как </em>args и **kwargs, заранее заданными.
reduce(func, iterable[, initializer])       применяет функцию func к первым двум элементам последовательности iterable, 
                                            затем применяет func к результату и следующему элементу, и так далее, пока не будет обработан весь список. 
                                            Если указан initializer, он используется как первый элемент в последовательности.
cache(func)                                 декоратор, который кэширует результаты вызовов функции func с одинаковыми аргументами, чтобы избежать повторных вычислений.
wraps(wrapped[, assigned[, updated]])       декоратор, который копирует информацию об исходной функции wrapped в декорированную функцию. 
                                            Это позволяет сохранить метаданные, такие как имя функции, документацию и атрибуты.
total_ordering(cls)                         декоратор, который автоматически генерирует методы сравнения объектов 
                                            для класса cls на основе определения методов <strong>eq</strong>() и <strong>lt</strong>().
cmp_to_key(func)                            преобразует функцию func для использования в функциях сортировки. 
                                            Функция func(a, b) должна возвращать число, которое указывает порядок элементов a и b.
partialmethod(func, <em>args, </em>*kwargs)        возвращает частичный метод, который может быть вызван как метод экземпляра класса. 
                                            Аргумент func должен быть методом класса.
lru_cache                                   декоратор реализует механизм кеширования результатов функции с помощью алгоритма "Least Recently Used" (LRU).
partial(func, <em>args, </em><em>kwargs)<br />
Возвращает новую функцию, которая является копией исходной функции func, 
но с некоторыми аргументами, переданными как </em>args и **kwargs, заранее заданными.
<pre><code class="language-python">from functools import partial

def power(base, exponent)
    return base ** exponent

# Создаем функцию возведения в квадрат, используя partial
square = partial(power, exponent=2)

# Вызываем функции
print(square(2))  # Output: 4
print(square(3))  # Output: 9
</code></pre>
reduce(func, iterable[, initializer]) 
Применяет функцию func к первым двум элементам последовательности iterable, затем применяет func к результату и следующему элементу, 
и так далее, пока не будет обработан весь список. Если указан initializer, он используется как первый элемент в последовательности.
<pre><code class="language-python">from functools import reduce

numbers = [1, 2, 3, 4, 5]

# Найдем произведение всех чисел в списке
product = reduce(lambda x, y: x*y, numbers)

print(product)  # Output: 120
</code></pre>
cache(func): 
Декоратор, который кэширует результаты вызовов функции func с одинаковыми аргументами, чтобы избежать повторных вычислений.
<pre><code class="language-python">from functools import cache

@cache
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(5))  # Output: 120
</code></pre>
wraps(wrapped[, assigned[, updated]]) 
Декоратор, который копирует информацию об исходной функции wrapped в декорированную функцию. 
Это позволяет сохранить метаданные, такие как имя функции, документацию и атрибуты.
| сохраняет имя и документацию функции так как обычный декоратор заменяет собой функцию
<pre><code class="language-python">from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(&quot;Calling function:&quot;, func.__name__)
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def my_function():
    &quot;&quot;&quot;This is my function.&quot;&quot;&quot;
    print(&quot;Hello, World!&quot;)

print(my_function.__name__)  # Output: my_function
print(my_function.__doc__)   # Output: This is my function.
</code></pre>
<pre><code class="language-python-console">&gt;&gt;&gt; def dec(f):
...     def w(x, y):
...         return f(x, y)
...     return w
...
&gt;&gt;&gt; @dec
... def foo(x, y):
...     &quot;&quot;&quot;comment&quot;&quot;&quot;
...     return x + y
...
&gt;&gt;&gt; foo
&amp;lt;function dec.&amp;lt;locals&gt;.w at 0x00000182FB1982C0&gt;
&gt;&gt;&gt; foo.__name__
'w'
&gt;&gt;&gt; from functools import wraps
&gt;&gt;&gt; def dec(f):
...     @wraps(f)
...     def w(x, y):
...         return f(x, y)
...     return w
...
&gt;&gt;&gt; @dec
... def foo(x, y):
...     &quot;&quot;&quot;comment&quot;&quot;&quot;
...     return x + y
...
&gt;&gt;&gt; foo
&amp;lt;function foo at 0x00000182FB198400&gt;
&gt;&gt;&gt; foo.__name__
'foo'
&gt;&gt;&gt;
</code></pre>
total_ordering(cls) 
Декоратор, который автоматически генерирует методы сравнения объектов 
для класса cls на основе определения методов <strong>eq</strong>() и <strong>lt</strong>().
<pre><code class="language-python">from functools import total_ordering

@total_ordering
class Person:
    def __init__(self, name, age):
        self.name = name
    def __eq__(self, other):
        return self.age == other.age

    def __lt__(self, other):
        return self.age &amp;lt; other.age

person1 = Person(&quot;Alice&quot;, 25)
person2 = Person(&quot;Bob&quot;, 30)

print(person1 == person2)  # Output: False
print(person1 != person2)  # Output: True
print(person1 &amp;lt; person2)   # Output: True
print(person1 &gt; person2)   # Output: False
</code></pre>
cmp_to_key(cmp) 
Преобразует функцию сравнения cmp в ключ-функцию, которая может быть использована для сортировки объектов. 
Эта функция полезна, когда необходимо отсортировать список объектов с использованием пользовательской функции сравнения.
<pre><code class="language-python">from functools import cmp_to_key

def my_cmp(a, b):
    if a &amp;lt; b:
        return -1
    elif a &gt; b:
        return 1
    else:
        return 0

numbers = [4, 2, 7, 1, 3]

sorted_numbers = sorted(numbers, key=cmp_to_key(my_cmp))

print(sorted_numbers)  # Output: [1, 2, 3, 4, 7]
</code></pre>
lru_cache — это декоратор в модуле functools в Python, который реализует 
механизм кеширования результатов функции с помощью алгоритма "Least Recently Used" (LRU).
LRU-кеширование позволяет сохранять недавно использованные результаты функции в кеше, 
чтобы повторно использовать их при последующих вызовах функции с теми же параметрами. 
Когда кеш заполнен до определенной максимальной величины, самые редко используемые 
элементы будут удалены из кеша, чтобы освободить место для новых элементов.
Для использования lru_cache необходимо импортировать модуль functools и применить декоратор @functools.lru_cache() к функции, 
которую нужно кешировать. Опционально можно передать в декоратор максимальное количество 
элементов в кеше (maxsize). Если параметр не задан, по умолчанию используется maxsize=128.
Например, вот как можно использовать lru_cache для кеширования результата функции fibonacci(n):
<pre><code class="language-python">from functools import lru_cache

@lru_cache(maxsize=128)
def fibonacci(n):
    if n &amp;lt;= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
</code></pre>
Этот код создает кеш для fibonacci с максимальным размером 128 элементов. 
При вызове fibonacci(n) для любого n, результат будет сохранен в кеше. 
При повторном вызове fibonacci(n) с тем же n, результат будет возвращен из кеша без повторного вычисления.