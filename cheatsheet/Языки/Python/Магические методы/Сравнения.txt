<strong>eq</strong>(self, other) - ==
<strong>ne</strong>(self, other) - !=
<strong>lt</strong>(self, other) - &lt;
<strong>gt</strong>(self, other) - &gt;
<strong>le</strong>(self, other) - &lt;=
<strong>ge</strong>(self, other) - &gt;=
<pre><code class="language-python">class Word(str):
    '''Класс для слов, определяющий сравнение по длине слов.'''
    def __new__(cls, word):
        # Мы должны использовать __new__, так как тип str неизменяемый
        # и мы должны инициализировать его раньше (при создании)
        if ' ' in word:
            print &quot;Value contains spaces. Truncating to first space.&quot;
            word = word[:word.index(' ')] 
            # Теперь Word это все символы до первого пробела
        return str.__new__(cls, word)

    def __gt__(self, other):
        return len(self) &gt; len(other)
    def __lt__(self, other):
        return len(self) &amp;lt; len(other)
    def __ge__(self, other):
        return len(self) &gt;= len(other)
    def __le__(self, other):
        return len(self) &amp;lt;= len(other)
</code></pre>
Теперь мы можем создать два Word (при помощи Word('foo') и Word('bar')) и сравнить их по длине. 
Заметьте, что мы не определяли <strong>eq</strong> и <strong>ne</strong>, так как это приведёт к странному поведению 
(например, Word('foo') == Word('bar') будет расцениваться как истина)
Стандартная библиотека предоставляет нам класс-декторатор в модуле functools, 
который и определит все сравнивающие методы, от вас достаточно 
определить только <strong>eq</strong> и ещё один (<strong>gt</strong>, <strong>lt</strong> и т.п.) 
Для того, чтобы задействовать её, поместите @total_ordering над вашим определением класса.