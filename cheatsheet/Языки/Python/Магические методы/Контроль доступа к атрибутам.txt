<strong>getattr</strong>(self, name)              Вы можете определить поведение для случая, когда пользователь пытается обратиться 
                                     к атрибуту, который не существует (совсем или пока ещё). 
                                     Это может быть полезным для перехвата и перенаправления частых опечаток, 
                                     предупреждения об использовании устаревших атрибутов 
                                     (вы можете всё-равно вычислить и вернуть этот атрибут, если хотите), 
                                     или хитро возвращать AttributeError, когда это вам нужно. 
                                     Правда, этот метод вызывается только когда пытаются получить 
                                     доступ к несуществующему атрибуту, поэтому это не очень хорошее решение для инкапсуляции.
<strong>setattr</strong>(self, name, value)       В отличии от <strong>getattr</strong>, <strong>setattr</strong> решение для инкапсуляции. 
                                     Этот метод позволяет вам определить поведение для присвоения значения атрибуту, 
                                     независимо от того существует атрибут или нет. 
                                     То есть, вы можете определить любые правила для любых изменений значения атрибутов. 
                                     Впрочем, вы должны быть осторожны с тем, как использовать <strong>setattr</strong>, 
                                     смотрите пример нехорошего случая в конце этого списка.
<strong>delattr</strong>                          Это то же, что и <strong>setattr</strong>, но для удаления атрибутов, вместо установки значений. 
                                     Здесь требуются те же меры предосторожности, что и в <strong>setattr</strong> чтобы избежать 
                                     бесконечной рекурсии (вызов del self.name в определении <strong>delattr</strong> вызовет бесконечную рекурсию)
<strong>getattribute</strong>(self, name)         Выглядит к месту среди своих коллег <strong>setattr</strong> и <strong>delattr</strong>, 
                                     но я бы не рекомендовал вам его использовать. <strong>getattribute</strong> может использоваться 
                                     только с классами нового типа (в новых версиях Питона все классы нового типа, а в старых версиях 
                                     вы можете получить такой класс унаследовавшись от object). 
                                     Этот метод позволяет вам определить поведение для каждого случая доступа к атрибутам 
                                     (а не только к несуществующим, как <strong>getattr</strong>(self, name)). 
                                     Он страдает от таких же проблем с бесконечной рекурсией, как и его коллеги 
                                     (на этот раз вы можете вызывать <strong>getattribute</strong> у базового класса, чтобы их предотвратить). 
                                     Он, так же, главным образом устраняет необходимость в <strong>getattr</strong>, 
                                     который в случае реализации <strong>getattribute</strong> может быть вызван только явным образом 
                                     или в случае генерации исключения AttributeError. 
                                     Вы конечно можете использовать этот метод (в конце концов, это ваш выбор), 
                                     но я бы не рекомендовал, потому что случаев, когда он действительно полезен очень мало 
                                     (намного реже нужно переопределять поведение при получении, а не при установке значения) 
                                     и реализовать его без возможных ошибок очень сложно.
Вы можете запросто получить проблему при определении любого метода, управляющего доступом к атрибутам. Рассмотрим пример:
<pre><code class="language-python">def __setattr__(self, name, value):
    self.name = value
    # это рекурсия, так как всякий раз, когда любому атрибуту присваивается значение,
    # вызывается  __setattr__().
    # тоесть, на самом деле это равнозначно self.__setattr__('name', value). 
    # Так как метод вызывает сам себя, рекурсия продолжится бесконечно, пока всё не упадёт

def __setattr__(self, name, value):
    self.__dict__[name] = value # присваивание в словарь переменных класса
    # дальше определение произвольного поведения
</code></pre>
Ещё раз, мощь магических методов в Питоне невероятна, а с большой силой 
приходит и большая ответственность. 
Важно знать, как правильно использовать магические методы, ничего не ломая.
Вот пример использования методов контроля доступа 
(заметьте, что мы используем super, так как не все классы имеют атрибут <strong>dict</strong>):
<pre><code class="language-python">class AccessCounter(object):
    '''Класс, содержащий атрибут value и реализующий счётчик доступа к нему.
    Счётчик увеличивается каждый раз, когда меняется value.'''

    def __init__(self, val):
        super(AccessCounter, self).__setattr__('counter', 0)
        super(AccessCounter, self).__setattr__('value', val)

    def __setattr__(self, name, value):
        if name == 'value':
            super(AccessCounter, self).__setattr__('counter', self.counter + 1)
        # Не будем делать здесь никаких условий.
        # Если вы хотите предотвратить изменение других атрибутов,
        # выбросьте исключение AttributeError(name)
        super(AccessCounter, self).__setattr__(name, value)

    def __delattr__(self, name):
        if name == 'value':
            super(AccessCounter, self).__setattr__('counter', self.counter + 1)
        super(AccessCounter, self).__delattr__(name)]
</code></pre>