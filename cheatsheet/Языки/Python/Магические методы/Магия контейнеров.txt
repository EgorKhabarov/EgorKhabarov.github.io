В Питоне существует множество способов заставить ваши классы вести себя как встроенные последовательности 
(словари, кортежи, списки, строки и так далее). 
Это, безусловно, мои любимые магические методы, из-за до абсурда высокой степени контроля, 
которую они дают и той магии, от которой с экземплярами ваших классов вдруг начинает прекрасно 
работать целое множество глобальных функций. 
Но, до того как мы перейдём ко всяким хорошим вещам, мы должны знать о протоколах.
Протоколы немного похожи на интерфейсы в других языках тем, что они предоставляют 
набор методов, которые вы должны реализовать. 
Однако, в Питоне протоколы абсолютно ни к чему не обязывают и не требуют 
обязательно реализовать какое-либо объявление. 
Наверное, они больше похожи на руководящие указания.
Протокол для определения неизменяемых контейнеров: чтобы создать неизменяемый контейнер, вы должны только определить <strong>len</strong> и <strong>getitem</strong>
Протокол изменяемого контейнера требует того же, что и неизменяемого контейнера, плюс <strong>setitem</strong> и <strong>delitem</strong>
Если вы хотите, чтобы ваши объекты можно было перебирать итерацией, вы должны определить <strong>iter</strong>, который возвращает итератор. 
Этот итератор должен соответствовать протоколу итератора, который требует методов <strong>iter</strong>(возвращает самого себя) и <strong>next</strong>.
<strong>len</strong>(self)                  Кколичество элементов в контейнере. Часть протоколов для изменяемого и неизменяемого контейнеров.
<strong>getitem</strong>(self, key)         Поведение при доступе к элементу, используя синтаксис self[key]. 
                               Тоже относится и к протоколу изменяемых и к протоколу неизменяемых контейнеров. 
                               Должен выбрасывать соответствующие исключения: 
                               TypeError если неправильный тип ключа и KeyError если ключу не соответствует никакого значения.
<strong>setitem</strong>(self, key, value)  Определяет поведение при присваивании значения элементу, 
                               используя синтаксис self[nkey] = value. 
                               Часть протокола изменяемого контейнера. 
                               Опять же, вы должны выбрасывать KeyError и TypeError в соответсвующий случаях.
<strong>delitem</strong>(self, key)         Определяет поведение при удалении элемента (то есть del self[key]). 
                               Это часть только протокола для изменяемого контейнера. 
                               Вы должны выбрасывать соответствующее исключение, если ключ некорректен.
<strong>iter</strong>(self)                 Должен вернуть итератор для контейнера. 
                               Итераторы возвращаются в множестве ситуаций, главным образом для встроенной функции iter() 
                               и в случае перебора элементов контейнера выражением for x in container:. 
                               Итераторы сами по себе объекты и они тоже должны определять метод <strong>iter</strong>, который возвращает self.
<strong>reversed</strong>(self)             Вызывается чтобы определить поведения для встроенной функции reversed(). 
                               Должен вернуть обратную версию последовательности. 
                               Реализуйте метод только если класс упорядоченный, как список или кортеж.
<strong>contains</strong>(self, item)       Предназначен для проверки принадлежности элемента с помощью in и not in. 
                               Вы спросите, почему же это не часть протокола последовательности? 
                               Потому что когда <strong>contains</strong> не определён, Питон просто перебирает всю последовательность 
                               элемент за элементом и возвращает True если находит нужный.
<strong>missing</strong>(self, key)         Используется при наследовании от dict. 
                               Определяет поведение для для каждого случая, когда пытаются получить элемент по 
                               несуществующему ключу (так, например, если у меня есть словарь d и я пишу d["george"] 
                               когда "george" не является ключом в словаре, вызывается d.<strong>missing</strong>("george")).
Пример
<pre><code class="language-python">class FunctionalList:
    '''Класс-обёртка над списком с добавлением некоторой функциональной магии: head,
    tail, init, last, drop, take.'''

    def __init__(self, values=None):
        if values is None:
            self.values = []
        else:
            self.values = values

    def __len__(self):
        return len(self.values)

    def __getitem__(self, key):
        # если значение или тип ключа некорректны, list выбросит исключение
        return self.values[key]

    def __setitem__(self, key, value):
        self.values[key] = value

    def __delitem__(self, key):
        del self.values[key]

    def __iter__(self):
        return iter(self.values)

    def __reversed__(self):
        return FunctionalList(reversed(self.values))

    def append(self, value):
        self.values.append(value)
    def head(self):
        # получить первый элемент
        return self.values[0]
    def tail(self):
        # получить все элементы после первого
        return self.values[1:]
    def init(self):
        # получить все элементы кроме последнего
        return self.values[:-1]
    def last(self):
        # получить последний элемент
        return self.values[-1]
    def drop(self, n):
        # все элементы кроме первых n
        return self.values[n:]
    def take(self, n):
        # первые n элементов
        return self.values[:n]
</code></pre>
Теперь у вас есть полезный (относительно) пример реализации своей собственной последовательности. 
Существуют, конечно, и куда более практичные реализации произвольных последовательностей, 
но большое их число уже реализовано в стандартной библиотеке, такие как Counter, OrderedDict, NamedTuple