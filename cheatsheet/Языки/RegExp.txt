Регуля́рные выраже́ния — формальный язык, используемый в компьютерных программах, 
работающих с текстом, для поиска и осуществления манипуляций с подстроками в тексте, 
основанный на использовании метасимволов. 
Для поиска используется строка-образец, состоящая из символов и 
метасимволов и задающая правило поиска.
<h1>Обозначения</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>Один любой символ, кроме новой строки \n.</td>
</tr>
<tr>
<td>\d</td>
<td>Любая цифра</td>
</tr>
<tr>
<td>\D</td>
<td>Любой символ, кроме цифры</td>
</tr>
<tr>
<td>\s</td>
<td>Любой пробельный символ (пробел, табуляция, конец строки и т.п.)</td>
</tr>
<tr>
<td>\S</td>
<td>Любой не пробельный символ</td>
</tr>
<tr>
<td>\w</td>
<td>Любая буква (то, что может быть частью слова), а также цифры и _</td>
</tr>
<tr>
<td>\W</td>
<td>Любая не-буква, не-цифра и не подчёркивание</td>
</tr>
<tr>
<td>[..]</td>
<td>Один из символов в скобках, а также любой символ из диапазона a-b [0-9][0-9A-Fa-f]</td>
</tr>
<tr>
<td>[^..]</td>
<td>Любой символ, кроме перечисленных &lt;[^&gt;]&gt;</td>
</tr>
<tr>
<td>\d≈[0-9]</td>
<td>Буква “ё” не включается в общий диапазон букв!</td>
</tr>
<tr>
<td>\D≈[^0-9]&lt;br&gt;\w≈[0-9a-zA-Zа-яА-ЯёЁ]&lt;br&gt;\s≈[ \f\n\r\t\v]</td>
<td>Вообще говоря, в \d включается всё, что в юникоде помечено как «цифра», а в \w — как буква</td>
</tr>
<tr>
<td>[abc-], [-1]</td>
<td>Если нужен минус, его нужно указать последним или первым</td>
</tr>
<tr>
<td>[*[(+\]\t]</td>
<td>Внутри скобок нужно экранировать только ] и \</td>
</tr>
<tr>
<td>\b</td>
<td>Начало или конец слова (слева пусто или не-буква, справа буква и наоборот).&lt;br&gt;В отличие от предыдущих соответствует позиции, а не символу</td>
</tr>
<tr>
<td>\B</td>
<td>Не граница слова: либо и слева, и справа буквы, либо и слева, и справа НЕ буквы</td>
</tr>
</tbody>
</table>
<h1>Повторения</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>{n}</td>
<td>Ровно n повторений</td>
</tr>
<tr>
<td>{m,n}</td>
<td>От m до n повторений включительно</td>
</tr>
<tr>
<td>{m,}</td>
<td>Не менее m повторений</td>
</tr>
<tr>
<td>{,n}</td>
<td>Не более n повторений</td>
</tr>
<tr>
<td>?</td>
<td>Ноль или одно вхождение, синоним {0,1}</td>
</tr>
<tr>
<td>*</td>
<td>Ноль или более, синоним {0,}</td>
</tr>
<tr>
<td>+</td>
<td>Одно или более, синоним {1,}</td>
</tr>
<tr>
<td>*?  +?  ??  {m,n}?</td>
<td>По умолчанию квантификаторы жадные — захватывают максимально возможное число символов.</td>
</tr>
<tr>
<td>{,n}?  {m,}?</td>
<td>Добавление ? делает их ленивыми, они захватывают минимально возможное число символов</td>
</tr>
</tbody>
</table>
<h1>Начало &amp; конец</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>Начало всего текста или начало строчки текста, если flags=re.MULTILINE</td>
</tr>
<tr>
<td>$</td>
<td>Конец всего текста или конец строчки текста, если flags=re.MULTILINE</td>
</tr>
<tr>
<td>\A</td>
<td>Строго начало всего текста</td>
</tr>
<tr>
<td>\Z</td>
<td>Строго конец всего текста</td>
</tr>
<tr>
<td>\b</td>
<td>Начало или конец слова (слева пусто или не-буква, справа буква и наоборот)</td>
</tr>
<tr>
<td>\B</td>
<td>Не граница слова: либо и слева, и справа буквы, либо и слева, и справа НЕ буквы</td>
</tr>
</tbody>
</table>
<h1>.</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>(?:...)</td>
<td>Позволяют локализовать часть шаблона, внутри которого происходит перечисление</td>
</tr>
<tr>
<td>(?=...)</td>
<td>Соответствует каждой позиции, сразу после которой НАЧИНАЕТСЯ соответствие шаблону ...</td>
</tr>
<tr>
<td>(?!...)</td>
<td>Соответствует каждой позиции, сразу после которой НЕ МОЖЕТ НАЧИНАТЬСЯ шаблон ...</td>
</tr>
<tr>
<td>(?&lt;=...)</td>
<td>Соответствует каждой позиции, которой может ЗАКАНЧИВАТЬСЯ шаблон ...&lt;br&gt;Длина шаблона должна быть фиксированной, то есть abc и a</td>
</tr>
<tr>
<td>(?&lt;!...)</td>
<td>Соответствует каждой позиции, которой НЕ МОЖЕТ ЗАКАНЧИВАТЬСЯ шаблон ...</td>
</tr>
</tbody>
</table>
<h1>Флаги</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>re.ASCII</td>
<td>По умолчанию \w, \W, \b, \B, \d, \D, \s, \S соответствуют все юникодные&lt;br&gt;символы с соответствующим качеством. Ускоряет работу, если все соответствия лежат внутри ASCII.</td>
</tr>
<tr>
<td>re.IGNORECASE</td>
<td>Не различать заглавные и маленькие буквы. Работает медленнее, но иногда удобно</td>
</tr>
<tr>
<td>re.MULTILINE</td>
<td>Специальные символы ^ и $ соответствуют началу и концу каждой строки</td>
</tr>
<tr>
<td>re.DOTALL</td>
<td>По умолчанию символ \n конца строки не подходит под точку. С этим флагом точка — вообще любой символ</td>
</tr>
</tbody>
</table>
<h1>Команды</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>re.search(pattern, string)</td>
<td>Найти в строке string первую строчку, подходящую под шаблон pattern</td>
</tr>
<tr>
<td>re.fullmatch(pattern, string)</td>
<td>Проверить, подходит ли строка string под шаблон pattern</td>
</tr>
<tr>
<td>re.split(pattern, string, maxsplit=0)</td>
<td>Аналог str.split(), только разделение происходит по подстрокам, подходящим под шаблон pattern</td>
</tr>
<tr>
<td>re.findall(pattern, string)</td>
<td>Найти в строке string все непересекающиеся шаблоны pattern</td>
</tr>
<tr>
<td>re.finditer(pattern, string)</td>
<td>Итератор всем непересекающимся шаблонам pattern в строке string (выдаются match-объекты)</td>
</tr>
<tr>
<td>re.sub(pattern, repl, string, count=0)</td>
<td>Заменить в строке string все непересекающиеся шаблоны pattern на repl</td>
</tr>
</tbody>
</table>
<pre><code class="language-RE">import re 
def repl(m): 
    return '&gt;censored(' + str(len(m[0])) + ')&amp;lt;' 
text = &quot;Некоторые хорошие слова подозрительны: хор, хоровод, хороводоводовед.&quot; 
print(re.sub(r'\b[хХxX]\w*', repl, text)) 
# -&gt; Некоторые &gt;censored(7)&amp;lt; слова подозрительны: &gt;censored(3)&amp;lt;, &gt;censored(7)&amp;lt;, &gt;censored(15)&amp;lt;. 
</code></pre>
Примеры
Номер кредитки:
<pre><code class="language-RE">[0-9]{13,16}
</code></pre>
ICQ:
<pre><code class="language-RE">([1-9])+(?:-?\d){4,}
</code></pre>
Набор из букв и цифр (латиница):
<pre><code class="language-RE">^[a-zA-Z0-9]+$
</code></pre>
Набор из букв и цифр (латиница + кириллица):
<pre><code class="language-RE">^[а-яА-ЯёЁa-zA-Z0-9]+$
</code></pre>
Домен (например seo-zona.ru):
<pre><code class="language-RE">^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}$
</code></pre>
IPv4:
<pre><code class="language-RE">((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)
</code></pre>
IPv6:
<pre><code class="language-RE">((^|:)([0-9a-fA-F]{0,4})){1,8}$
</code></pre>
Имя пользователя (с ограничением 2-20 символов, 
которыми могут быть буквы и цифры, первый символ обязательно буква):
<pre><code class="language-RE">^[a-zA-Z][a-zA-Z0-9-_\.]{1,20}$
</code></pre>
Дата в формате YYYY-MM-DD:
<pre><code class="language-RE">[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|1[0-9]|2[0-9]|3[01])
</code></pre>
Дата в формате DD/MM/YYYY:
<pre><code class="language-RE">(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)\d\d
</code></pre>
Целые числа и числа с плавающей точкой (разделитель точка):
<pre><code class="language-RE">\-?\d+(\.\d{0,})?
</code></pre>
UUID:
<pre><code class="language-RE">^[0-9A-Fa-f]{8}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{12}$
</code></pre>
Широта или долгота:
<pre><code class="language-RE">-?\d{1,3}\.\d+
</code></pre>