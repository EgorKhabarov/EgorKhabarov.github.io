Целые числа
<pre><code>short int - предназначен для хранения целых чисел. Диапазон чисел от -32 768 до 32 767;

unsigned short int - предназначен для хранения целых положительных чисел. Диапазон чисел от 0 до 65 535;

int - предназначен для хранения целых чисел. Диапазон чисел от -2 147 483 648 до 2 147 483 647;

unsigned int - предназначен для хранения целых положительных чисел. Диапазон чисел от 0 до 4 294 967 295;

long int - предназначен для хранения целых чисел. Диапазон чисел от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807;

unsigned long int - предназначен для хранения целых положительных чисел. Диапазон чисел от 0 до 18 446 744 073 709 551 615.
</code></pre>
Разница между типами заключается только в диапазоне чисел, который можно записать в переменную. 
Также не используйте большие типы данных по типу long int, если число маленькое, 
так как чем больше диапазон, тем больше памяти требуется компьютеру на конкретную переменную.
Числа с точкой
<pre><code>float - для создания чисел с плавающей точкой. Диапазон чисел от от -3.4*1038 до 3.4*1038;

double или long float - для создания чисел с плавающей точкой. Диапазон чисел от от ±4.9*10-324 до ±1.8*10308.
</code></pre>
Прочие типы данных
<pre><code>bool - логический тип данных. Предназначен для записи истинного (true) или ложного (false) значения;

char - тип данных для работы с символами. Позволяет поместить в одинарных кавычках какой-либо символ.
</code></pre>
Для создания переменной необходимо указать тип данных и назвать её. Также можно сразу же добавить к ней значение:
<pre><code>int a = 0; // Добавление значения сразу
float c; // Создание переменной без значения
short int b, y = 342; // Создание нескольких переменных
</code></pre>
Для вызова переменной вы можете обратиться к ней по имени.
Получение данных
Для получения данных от пользователя необходимо воспользоваться командой cin:
<pre><code>cin &gt;&gt; some_value;
</code></pre>
Таким образом введенные пользователем данные будут помещены в переменную с названием «some_value».
<pre><code>char c = '1';    // символ
bool b = true;   // логическая переменная, принимает значения false и true
int i = 42;      // целое число (занимает, как правило, 4 байта)
short int i = 17;            // короткое целое (занимает 2 байта)
long li = 12321321312;       // длинное целое (как правило, 8 байт)
long long lli = 12321321312; // длинное целое (как правило, 16 байт)
float f = 2.71828;           // дробное число с плавающей запятой (4 байта)
double d = 3.141592;         // дробное число двойной точности (8 байт)
long double ld = 1e15;       // длинное дробное (как правило, 16 байт)
</code></pre>
<pre><code>std::cout &amp;lt;&amp;lt; &quot;char: &quot; &amp;lt;&amp;lt; sizeof(char) &amp;lt;&amp;lt; &quot;
&quot;;                 //  1
std::cout &amp;lt;&amp;lt; &quot;bool: &quot; &amp;lt;&amp;lt; sizeof(bool) &amp;lt;&amp;lt; &quot;
&quot;;                 //  1
std::cout &amp;lt;&amp;lt; &quot;short int: &quot; &amp;lt;&amp;lt; sizeof(short int) &amp;lt;&amp;lt; &quot;
&quot;;       //  2 (по стандарту &gt;= 2)
std::cout &amp;lt;&amp;lt; &quot;int: &quot; &amp;lt;&amp;lt; sizeof(int) &amp;lt;&amp;lt; &quot;
&quot;;                   //  4 (по стандарту &gt;= 2)
std::cout &amp;lt;&amp;lt; &quot;long int: &quot; &amp;lt;&amp;lt; sizeof(long int) &amp;lt;&amp;lt; &quot;
&quot;;         //  8 (по стандарту &gt;= 4)
std::cout &amp;lt;&amp;lt; &quot;long long int: &quot; &amp;lt;&amp;lt; sizeof(long long) &amp;lt;&amp;lt; &quot;
&quot;;   //  8 (по стандарту &gt;= 8)
std::cout &amp;lt;&amp;lt; &quot;float: &quot; &amp;lt;&amp;lt; sizeof(float) &amp;lt;&amp;lt; &quot;
&quot;;               //  4
std::cout &amp;lt;&amp;lt; &quot;double: &quot; &amp;lt;&amp;lt; sizeof(double) &amp;lt;&amp;lt; &quot;
&quot;;             //  8
std::cout &amp;lt;&amp;lt; &quot;long double: &quot; &amp;lt;&amp;lt; sizeof(long double) &amp;lt;&amp;lt; &quot;
&quot;;   // 16
</code></pre>
Приведённые выше примеры вывода оператора sizeof верны для 64-битных архитектур, которые на сегодняшний день распространены повсеместно. 
Однако если бы мы скомпилировали и запустили такую программу на компьютере с 32-битной архитектурой, то получили бы другие результаты. 
Например, sizeof(long int) стал бы равен 4, в то время как на современных компьютерах мы получили бы 8. 
Также бывают встраиваемые системы, под которые тоже можно писать на С++. Там битность архитектуры может быть ещё меньше, чем 32.
В заголовочном файле cstdint стандартной библиотеки имеются целочисленные типы с фиксированным размером:
int8_t / uint8_t
int16_t / uint16_t
int32_t / uint32_t
int64_t / uint64_t
Число в имени типа означает количество бит, используемых для хранения в памяти. 
Например, int32_t содержит 32 бита (4 байта) и часто соответствует типу int. 
Если система не поддерживает какой-то тип, то программа с ним просто не скомпилируется.
Арифметические операции
Бинарные операции +, - и * работают для чисел стандартным образом. 
Результат операции деления /, применённой к целым числам, всегда округляется в сторону нуля. 
Таким образом, для положительных чисел операция / возвращает неполное частное. 
Остаток от деления целых чисел можно получить с помощью операции %.
<pre><code class="language-cpp">int main() {
    int a = 7, b = 3;
    int q = a / b;  // 2
    int r = a % b;  // 1
}
</code></pre>
Если при делении нужно получить обычное частное, то один из аргументов нужно привести к вещественному типу (например, double) с помощью оператора static_cast:
<pre><code class="language-cpp">int main() {
    int a = 6, b = 4;
    double q = static_cast&amp;lt;double&gt;(a) / b;  // 1.5
}
</code></pre>
Можно было бы написать чуть более кратко: double q = a * 1.0 / b;. 
Тогда преобразование аргументов произошло бы неявно.
Арифметические операции над символами, а также сравнение символов друг с другом — это фактически операции над их ASCII-кодами:
<pre><code class="language-cpp">#include &amp;lt;iostream&gt;

int main() {
    char c = 'A';
    c += 25;  // увеличиваем ASCII-код символа на 25
    std::cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &quot;
&quot;;  // Z
}
</code></pre>