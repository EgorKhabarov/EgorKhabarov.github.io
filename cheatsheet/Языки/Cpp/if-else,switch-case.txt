&amp;&amp; (И)
|| (ИЛИ)
! (НЕ)
Если необходимо проверить несколько условий в одном операторе, 
то можно воспользоваться логическим «и» или же логическим «или»:
<pre><code class="language-cpp">if (a != b &amp;&amp; a &gt; b) {
    // Код будет выполнен, если и первое, и второе условие
    // окажутся верными
}

if (a &amp;lt; b || a == b) {
    // Код будет выполнен, если или первое, или второе условие
    // окажется верным
}
</code></pre>
Тернарная операция
Это сокращенная форма if else. Записывается следующим образом:
<pre><code class="language-cpp">int x = 90, a = 8;
int res = x &amp;lt; a ? (x + a) : (x - a);
cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;
</code></pre>
Проверяем: если “x” будет меньше “а”, то в переменную res устанавливаем их сумму, иначе – их разницу. 
Конструкция switch
Конструкция case обладает более удобным форматом для проверки множественных условий на совпадение значения. 
В конструкцию записывается переменная, что проверяется, а также значения на которые происходит проверка.
Пример оператора:
<pre><code class="language-cpp">int x = 23;
switch (x) { // Проверяем переменную x
    case 1: // Если переменная будет равна 1, то здесь сработает код
        // Может быть множество строк, а не только одна
        cout &amp;lt;&amp;lt; &quot;Переменная равна 1&quot; &amp;lt;&amp;lt; endl;
        break; // Указываем конец для кода для этой проверки
    case 56: // Если переменная будет равна 56, то здесь сработает код
        // Может быть множество строк, а не только одна
        cout &amp;lt;&amp;lt; &quot;Переменная равна 56&quot; &amp;lt;&amp;lt; endl;
        break; // Указываем конец для кода для этой проверки
        // По аналогии таких проверок может быть множество
        // Также можно добавить проверку, которая сработает в случае
        // если все остальные проверки не сработают
    default:
        cout &amp;lt;&amp;lt; &quot;Что-то другое&quot; &amp;lt;&amp;lt; endl;
        break; // Можно и не ставить, так как это последние условие
}
</code></pre>
Операторы &amp;&amp; и || ведут себя лениво: если первого аргумента уже достаточно для ответа, то второй аргумент вычисляться не будет. 
Например, в выражении condition1 &amp;&amp; condition2 второе условие не вычисляется, если первое ложно.
Сравнение чисел с плавающей точкой
Рассмотрим программу, которая проверяет равенство 0.1 + 0.2 == 0.3:
<pre><code class="language-cpp">#include &amp;lt;iostream&gt;

int main() {
    double x = 0.1, y = 0.2;
    if (x + y == 0.3) {
        std::cout &amp;lt;&amp;lt; &quot;EQUAL &quot;;
    } else {
        std::cout &amp;lt;&amp;lt; &quot;NOT EQUAL &quot;;
    }

    std::cout &amp;lt;&amp;lt; x + y &amp;lt;&amp;lt; &quot;\n&quot;;
}
</code></pre>
Логично было бы предположить, что программа выведет EQUAL 0.3, потому что . 
Однако программа напечатает NOT EQUAL 0.3. 
Данная «ошибка вычисления» встречается в большинстве современных языков программирования и обусловлена погрешностью представления этих чисел. 
Если повысить число знаков дробной части в выводе, мы увидим, что 0.1 + 0.2 == 0.30000000000000004.
Поскольку операции над числами с плавающей точкой могут содержать погрешность, обычное сравнение через == некорректно. 
Поэтому правильнее сравнивать модуль разности величин с некой допустимой для нас погрешностью. 
Модуль дробного числа можно получить с помощью функции std::abs из заголовочного файла cmath. 
Исходную программу можно было бы переписать так:
<pre><code class="language-cpp">#include &amp;lt;cmath&gt;
#include &amp;lt;iostream&gt;

int main() {
    double delta = 0.000001;

    double x = 0.1, y = 0.2;
    double sum = x + y;

    if (std::abs(sum - 0.3) &amp;lt; delta) {
        std::cout &amp;lt;&amp;lt; &quot;EQUAL &quot;;
    } else {
        std::cout &amp;lt;&amp;lt; &quot;NOT EQUAL &quot;;
    }

    std::cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; &quot;\n&quot;;
}
// Теперь программа выведет EQUAL 0.3.
</code></pre>