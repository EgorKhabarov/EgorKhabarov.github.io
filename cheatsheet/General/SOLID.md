<h1>SOLID</h1>
<h2>S</h2>
<p><strong>Single Responsibility</strong> (Принцип единственной ответственности)
Каждый класс должен отвечать только за одну операцию</p>
<h2>O</h2>
<p><strong>Open-Closed</strong> (Принцип открытости-закрытости)
Классы должны быть открыты для расширения, но закрыты для модификации</p>
<h2>L</h2>
<p><strong>Liskov Substitution</strong> (Принцип подстановки Барбары Лисков)
Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе,
могут заменяться объектами типа П без негативных последствий для функциональности программы</p>
<h2>I</h2>
<p><strong>Interface Segregation</strong> (Принцип разделения интерфейсов)
Не следует ставить клиент в зависимость от методов, которые он не использует</p>
<h2>D</h2>
<p><strong>Dependency Inversion</strong> (Принцип инверсии зависимостей)
Модули верхнего уровня не должны зависеть от модулей нижнего уровня
И те, и другие должны зависеть от абстракций
Абстракции не должны зависеть от деталей
Детали должны зависеть от абстракций</p>
<p>Модули (или классы) верхнего уровня = классы, которые выполняют операцию при помощи инструмента
Модули (или классы) нижнего уровня = инструменты, которые нужны для выполнения операций
Абстракции – представляют интерфейс, соединяющий два класса
Детали = специфические характеристики работы инструмента</p>
<p>Согласно данному принципу, класс не должен соединяться с инструментом, который применяет для выполнения операции
Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом</p>
<p>Кроме того, принцип гласит, что ни интерфейс, ни класс, не обязаны вникать в специфику работы инструмента
Напротив, это инструмент должен подходить под требования интерфейса</p>
<p><a href="https://habr.com/ru/companies/productivity_inside/articles/505430/">https://habr.com/ru/companies/productivity_inside/articles/505430/</a></p>