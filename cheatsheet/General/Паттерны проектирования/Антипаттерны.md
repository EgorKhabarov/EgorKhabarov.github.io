<p>Антипаттерн — это распространенный подход к решению часто встречающихся проблем,
который может нанести больше вреда, чем пользы.</p>
<p><a href="https://ru.wikipedia.org/wiki/Антипаттерн">https://ru.wikipedia.org/wiki/Антипаттерн</a>
<a href="https://habr.com/ru/companies/slurm/articles/706024/">https://habr.com/ru/companies/slurm/articles/706024/</a></p>
<ul>
<li><strong>Антипаттерны в объектно-ориентированном программировании</strong><ul>
<li><strong>Базовый класс-утилита (BaseBean)</strong>
Наследование функциональности из класса-утилиты вместо делегирования к нему.</li>
<li><strong>Anemic Domain Model</strong>
боязнь размещать логику в объектах предметной области.</li>
<li><strong>Вызов предка (Call super)</strong>
Для реализации прикладной функциональности методу класса-потомка требуется
в обязательном порядке вызывать те же методы класса-предка.</li>
<li><strong>Ошибка пустого подкласса (Empty subclass failure)</strong>
Создание класса (в Perl), который не проходит «проверку пустоты подкласса» («Empty Subclass Test»)
из-за различного поведения по сравнению с классом, который наследуется от него без изменений.</li>
<li><strong>Божественный объект (God object)</strong>
Концентрация слишком большого количества функций в одной части системы (классе).</li>
<li><strong>Объектная клоака (Object cesspool)</strong>
Переиспользование объектов, находящихся в непригодном для переиспользования состоянии.</li>
<li><strong>Полтергейст (Poltergeist)</strong>
Объекты, чьё единственное предназначение — передавать информацию другим объектам.</li>
<li><strong>Проблема йо-йо (Yo-yo problem)</strong>
Чрезмерная размытость сильно связанного кода (например, выполняемого по порядку) по иерархии классов.</li>
<li><strong>Одиночество (Singletonitis)</strong>
Неуместное использование паттерна одиночка.</li>
<li><strong>Френд-зона (Friend zone)</strong>
Неуместное использование дружественных классов и дружественных функций в языке C++.</li>
<li><strong>Каша из интерфейсов (Interface soup)</strong>
Объединение нескольких интерфейсов, разделенных согласно
принципу изоляции интерфейсов (Interface segregation), в один.</li>
<li><strong>Висящие концы</strong>
Интерфейс, большинство методов которого бессмысленны и реализуются «пустышками».</li>
<li><strong>Заглушка (Stub)</strong>
Попытка «натянуть» на объект уже имеющийся малоподходящий по смыслу интерфейс, вместо создания нового.</li>
</ul>
</li>
<li><strong>Антипаттерны при написании кода</strong><ul>
<li><strong>Ненужная сложность (Accidental complexity)</strong>
Внесение ненужной сложности в решение.</li>
<li><strong>Действие на расстоянии (Action at a distance)</strong>
Неожиданное взаимодействие между широко разделёнными частями системы.</li>
<li><strong>Накопить и запустить (Accumulate and fire)</strong>
Установка параметров подпрограмм в наборе глобальных переменных.</li>
<li><strong>Слепая вера (Blind faith)</strong>
Недостаточная проверка корректности исправления ошибки или результата работы подпрограммы.</li>
<li><strong>Лодочный якорь (Boat anchor)</strong>
Сохранение более не используемой части системы.</li>
<li><strong>Активное ожидание (Busy spin, busy waiting)</strong>
Потребление ресурсов ЦПУ (процессорного времени) во время ожидания события,
обычно при помощи постоянно повторяемой проверки,
вместо того, чтобы использовать асинхронное программирование (к примеру, систему сообщений или событий).</li>
<li><strong>Кэширование ошибки (Caching failure)</strong>
Забывать сбросить флаг ошибки после её обработки.</li>
<li><strong>Воняющий подгузник (The Diaper Pattern Stinks)</strong>
Сброс флага ошибки без её обработки или передачи вышестоящему обработчику.</li>
<li><strong>Проверка типа вместо интерфейса (Checking type instead of membership, Checking type instead of interface)</strong>
Проверка того, что объект имеет специфический тип в то время, когда требуется только определённый интерфейс.</li>
<li><strong>Инерция кода (Code momentum)</strong>
Сверхограничение части системы путём постоянного подразумевания её поведения в других частях системы.</li>
<li><strong>Кодирование путём исключения (Coding by exception)</strong>
Добавление нового кода для поддержки каждого специального распознанного случая.</li>
<li><strong>Таинственный код (Cryptic code)</strong>
Использование аббревиатур вместо мнемоничных имён.</li>
<li><strong>Жёсткое кодирование (Hard code)</strong>
Внедрение предположений об окружении системы в слишком большом количестве точек её реализации.</li>
<li><strong>Мягкое кодирование (Soft code)</strong>
Патологическая боязнь жёсткого кодирования, приводящая к тому, что настраивается всё что угодно,
при этом конфигурирование системы само по себе превращается в программирование.</li>
<li><strong>Поток лавы (Lava flow)</strong>
Сохранение нежелательного (излишнего или низкокачественного) кода по причине того,
что его удаление слишком дорого или будет иметь непредсказуемые последствия.</li>
<li><strong>Волшебные числа (Magic numbers)</strong>
Использование числовых констант без объяснения их смысла.</li>
<li><strong>Процедурный код (Procedural code)</strong>
Когда другая парадигма является более подходящей.</li>
<li><strong>Спагетти-код (Spaghetti code, иногда «макароны»)</strong>
Код с чрезмерно запутанным порядком выполнения.</li>
<li><strong>Лазанья-код (Lasagnia code, или «лук» (onion))</strong>
Чрезмерное связывание между собой уровней абстракции,
приводящее к невозможности изменения одного уровня без изменения остальных.</li>
<li><strong>Равиоли-код (Ravioli code, или «пельмени»)</strong>
Объекты настолько «склеены» между собой, что практически не допускают рефакторинга.</li>
<li><strong>Мыльный пузырь (Soap bubble)</strong>
Объект, инициализированый мусором, максимально долго притворяется, что содержит какие-то данные.</li>
<li><strong>Мьютексный ад (Mutex hell)</strong>
Внедрение слишком большого количества объектов синхронизации между потоками.</li>
<li><strong>(Мета-)шаблонный рак (Template cancer)</strong>
Повсеместное использование шаблонов (в основном C++), в том числе там, где их использование не оправдано.
Это уменьшает понимание и сопровождение кода и замедляет компиляцию.</li>
</ul>
</li>
<li><strong>Методологические антипаттерны</strong><ul>
<li><strong>Программирование методом копирования-вставки (Copy and paste programming)</strong>
Копирование (и лёгкая модификация) существующего кода вместо создания общих решений.</li>
<li><strong>Дефакторинг (De-Factoring)</strong>
Процесс уничтожения функциональности и замены её документацией.</li>
<li><strong>Золотой молоток (Golden hammer)</strong>
Сильная уверенность в том, что любимое решение универсально применимо.
Название происходит от поговорки «когда в руках молоток, все проблемы кажутся гвоздями».</li>
<li><strong>Фактор невероятности (Improbability factor)</strong>
Предположение о невозможности того, что сработает известная ошибка.</li>
<li><strong>Преждевременная оптимизация (Premature optimization)</strong>
Оптимизация на этапе проектирования сегмента кода, приводящая к его усложнению или искажению.</li>
<li><strong>Программирование методом подбора (Programming by permutation)</strong>
Подход к разработке программного обеспечения небольшими изменениями без понимания их смысла.</li>
<li><strong>Изобретение колеса/велосипеда (Reinventing the wheel)</strong>
Создание с нуля вместо использования хорошего готового решения.</li>
<li><strong>Изобретение квадратного колеса (Reinventing the square wheel)</strong>
Создание плохого решения, при условии, что уже существует известное решение лучше.</li>
<li><strong>Самоуничтожение (Self-destruction)</strong>
Фатальная ошибка либо нестандартное поведение программы, приводящая к отказу в обслуживании,
возникшая вследствие другой менее серьёзной ошибки. Например, при возникновении ошибки,
приложение начинает очень быстро и много писать в лог, вследствие чего заканчивается место
на жёстком диске быстрее, чем это обнаружит мониторинг.</li>
<li><strong>Два тоннеля</strong>
Вынесение новой функциональности в отдельное приложение вместо расширения уже имеющегося.
Чаще всего применяется, когда по каким-либо причинам (в основном, при нехватке времени либо нежелании менеджмента)
внесение изменений в уже имеющийся код требует больших затрат, чем создание нового.
При этом у клиента в конечном итоге работают два приложения,
запускаясь одновременно либо попеременно друг из друга.</li>
<li><strong>Коммит-убийца (Commit assasin)</strong>
Внесение отдельных изменений в систему контроля версий без проверки влияния их на другие части программы.
Как правило, после подобных коммитов работа коллектива парализуется
на время исправления проблем в местах, которые ранее работали безошибочно.</li>
</ul>
</li>
</ul>