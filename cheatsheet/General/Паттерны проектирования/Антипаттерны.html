<p>Антипаттерн — это распространенный подход к решению часто встречающихся проблем,
который может нанести больше вреда, чем пользы.</p>
<p><a href="https://ru.wikipedia.org/wiki/Антипаттерн">https://ru.wikipedia.org/wiki/Антипаттерн</a>
<a href="https://habr.com/ru/companies/slurm/articles/706024/">https://habr.com/ru/companies/slurm/articles/706024/</a></p>
<h1>Антипаттерны в объектно-ориентированном программировании</h1>
<h3>Базовый класс-утилита (BaseBean)</h3>
<p>Наследование функциональности из класса-утилиты вместо делегирования к нему.</p>
<h3>Anemic Domain Model</h3>
<p>боязнь размещать логику в объектах предметной области.</p>
<h3>Вызов предка (Call super)</h3>
<p>Для реализации прикладной функциональности методу класса-потомка требуется
в обязательном порядке вызывать те же методы класса-предка.</p>
<h3>Ошибка пустого подкласса (Empty subclass failure)</h3>
<p>Создание класса (в Perl), который не проходит «проверку пустоты подкласса» («Empty Subclass Test»)
из-за различного поведения по сравнению с классом, который наследуется от него без изменений.</p>
<h3>Божественный объект (God object)</h3>
<p>Концентрация слишком большого количества функций в одной части системы (классе).</p>
<h3>Объектная клоака (Object cesspool)</h3>
<p>Переиспользование объектов, находящихся в непригодном для переиспользования состоянии.</p>
<h3>Полтергейст (Poltergeist)</h3>
<p>Объекты, чьё единственное предназначение — передавать информацию другим объектам.</p>
<h3>Проблема йо-йо (Yo-yo problem)</h3>
<p>Чрезмерная размытость сильно связанного кода (например, выполняемого по порядку) по иерархии классов.</p>
<h3>Одиночество (Singletonitis)</h3>
<p>Неуместное использование паттерна одиночка.</p>
<h3>Френд-зона (Friend zone)</h3>
<p>Неуместное использование дружественных классов и дружественных функций в языке C++.</p>
<h3>Каша из интерфейсов (Interface soup)</h3>
<p>Объединение нескольких интерфейсов, разделенных согласно
принципу изоляции интерфейсов (Interface segregation), в один.</p>
<h3>Висящие концы</h3>
<p>Интерфейс, большинство методов которого бессмысленны и реализуются «пустышками».</p>
<h3>Заглушка (Stub)</h3>
<p>Попытка «натянуть» на объект уже имеющийся малоподходящий по смыслу интерфейс, вместо создания нового.</p>
<h1>Антипаттерны при написании кода</h1>
<h3>Ненужная сложность (Accidental complexity)</h3>
<p>Внесение ненужной сложности в решение.</p>
<h3>Действие на расстоянии (Action at a distance)</h3>
<p>Неожиданное взаимодействие между широко разделёнными частями системы.</p>
<h3>Накопить и запустить (Accumulate and fire)</h3>
<p>Установка параметров подпрограмм в наборе глобальных переменных.</p>
<h3>Слепая вера (Blind faith)</h3>
<p>Недостаточная проверка корректности исправления ошибки или результата работы подпрограммы.</p>
<h3>Лодочный якорь (Boat anchor)</h3>
<p>Сохранение более не используемой части системы.</p>
<h3>Активное ожидание (Busy spin, busy waiting)</h3>
<p>Потребление ресурсов ЦПУ (процессорного времени) во время ожидания события,
обычно при помощи постоянно повторяемой проверки,
вместо того, чтобы использовать асинхронное программирование (к примеру, систему сообщений или событий).</p>
<h3>Кэширование ошибки (Caching failure)</h3>
<p>Забывать сбросить флаг ошибки после её обработки.</p>
<h3>Воняющий подгузник (The Diaper Pattern Stinks)</h3>
<p>Сброс флага ошибки без её обработки или передачи вышестоящему обработчику.</p>
<h3>Проверка типа вместо интерфейса (Checking type instead of membership, Checking type instead of interface)</h3>
<p>Проверка того, что объект имеет специфический тип в то время, когда требуется только определённый интерфейс.</p>
<h3>Инерция кода (Code momentum)</h3>
<p>Сверхограничение части системы путём постоянного подразумевания её поведения в других частях системы.</p>
<h3>Кодирование путём исключения (Coding by exception)</h3>
<p>Добавление нового кода для поддержки каждого специального распознанного случая.</p>
<h3>Таинственный код (Cryptic code)</h3>
<p>Использование аббревиатур вместо мнемоничных имён.</p>
<h3>Жёсткое кодирование (Hard code)</h3>
<p>Внедрение предположений об окружении системы в слишком большом количестве точек её реализации.</p>
<h3>Мягкое кодирование (Soft code)</h3>
<p>Патологическая боязнь жёсткого кодирования, приводящая к тому, что настраивается всё что угодно,
при этом конфигурирование системы само по себе превращается в программирование.</p>
<h3>Поток лавы (Lava flow)</h3>
<p>Сохранение нежелательного (излишнего или низкокачественного) кода по причине того,
что его удаление слишком дорого или будет иметь непредсказуемые последствия.</p>
<h3>Волшебные числа (Magic numbers)</h3>
<p>Использование числовых констант без объяснения их смысла.</p>
<h3>Процедурный код (Procedural code)</h3>
<p>Когда другая парадигма является более подходящей.</p>
<h3>Спагетти-код (Spaghetti code, иногда «макароны»)</h3>
<p>Код с чрезмерно запутанным порядком выполнения.</p>
<h3>Лазанья-код (Lasagnia code, или «лук» (onion))</h3>
<p>Чрезмерное связывание между собой уровней абстракции,
приводящее к невозможности изменения одного уровня без изменения остальных.</p>
<h3>Равиоли-код (Ravioli code, или «пельмени»)</h3>
<p>Объекты настолько «склеены» между собой, что практически не допускают рефакторинга.</p>
<h3>Мыльный пузырь (Soap bubble)</h3>
<p>Объект, инициализированый мусором, максимально долго притворяется, что содержит какие-то данные.</p>
<h3>Мьютексный ад (Mutex hell)</h3>
<p>Внедрение слишком большого количества объектов синхронизации между потоками.</p>
<h3>(Мета-)шаблонный рак (Template cancer)</h3>
<p>Повсеместное использование шаблонов (в основном C++), в том числе там, где их использование не оправдано.
Это уменьшает понимание и сопровождение кода и замедляет компиляцию.</p>
<h1>Методологические антипаттерны</h1>
<h3>Программирование методом копирования-вставки (Copy and paste programming)</h3>
<p>Копирование (и лёгкая модификация) существующего кода вместо создания общих решений.</p>
<h3>Дефакторинг (De-Factoring)</h3>
<p>Процесс уничтожения функциональности и замены её документацией.</p>
<h3>Золотой молоток (Golden hammer)</h3>
<p>Сильная уверенность в том, что любимое решение универсально применимо.
Название происходит от поговорки «когда в руках молоток, все проблемы кажутся гвоздями».</p>
<h3>Фактор невероятности (Improbability factor)</h3>
<p>Предположение о невозможности того, что сработает известная ошибка.</p>
<h3>Преждевременная оптимизация (Premature optimization)</h3>
<p>Оптимизация на этапе проектирования сегмента кода, приводящая к его усложнению или искажению.</p>
<h3>Программирование методом подбора (Programming by permutation)</h3>
<p>Подход к разработке программного обеспечения небольшими изменениями без понимания их смысла.</p>
<h3>Изобретение колеса/велосипеда (Reinventing the wheel)</h3>
<p>Создание с нуля вместо использования хорошего готового решения.</p>
<h3>Изобретение квадратного колеса (Reinventing the square wheel)</h3>
<p>Создание плохого решения, при условии, что уже существует известное решение лучше.</p>
<h3>Самоуничтожение (Self-destruction)</h3>
<p>Фатальная ошибка либо нестандартное поведение программы, приводящая к отказу в обслуживании,
возникшая вследствие другой менее серьёзной ошибки. Например, при возникновении ошибки,
приложение начинает очень быстро и много писать в лог, вследствие чего заканчивается место
на жёстком диске быстрее, чем это обнаружит мониторинг.</p>
<h3>Два тоннеля</h3>
<p>Вынесение новой функциональности в отдельное приложение вместо расширения уже имеющегося.
Чаще всего применяется, когда по каким-либо причинам (в основном, при нехватке времени либо нежелании менеджмента)
внесение изменений в уже имеющийся код требует больших затрат, чем создание нового.
При этом у клиента в конечном итоге работают два приложения,
запускаясь одновременно либо попеременно друг из друга.</p>
<h3>Коммит-убийца (Commit assasin)</h3>
<p>Внесение отдельных изменений в систему контроля версий без проверки влияния их на другие части программы.
Как правило, после подобных коммитов работа коллектива парализуется
на время исправления проблем в местах, которые ранее работали безошибочно.</p>