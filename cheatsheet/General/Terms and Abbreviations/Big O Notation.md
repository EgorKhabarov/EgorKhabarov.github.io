**O-нотация** (Big O Notation) — это математическая нотация, которая описывает поведение алгоритмов
с точки зрения их **асимптотической сложности**.
Она используется для оценки времени выполнения и потребляемой памяти в зависимости от размера входных данных.

# Важные понятия

- **Размер входных данных (n)**: Количество элементов, которые обрабатывает алгоритм.
- **Время выполнения**: Количество операций, выполняемых алгоритмом по мере увеличения входных данных.
- **Худший случай**: Сценарий, при котором алгоритм выполняется дольше всего.
- **Оценка сверху**: O-нотация всегда показывает верхнюю границу времени выполнения (или использования памяти) алгоритма.

# Основные классы сложности

| О-нотация      | Сложность                   | Описание                                                                               | Пример                                  |
|----------------|-----------------------------|----------------------------------------------------------------------------------------|-----------------------------------------|
| **O(1)**       | **Константная**             | Время выполнения не зависит от размера входных данных                                  | Доступ к элементу массива по индексу    |
| **O(log n)**   | **Логарифмическая**         | Время выполнения увеличивается логарифмически<br>по отношению к размеру входных данных | Бинарный поиск                          |
| **O(n)**       | **Линейная**                | Время выполнения растет линейно<br>с увеличением размера входных данных                | Линейный поиск в массиве                |
| **O(n log n)** | **Линейно-логарифмическая** | Увеличивается быстрее, чем O(n),<br>но медленнее, чем квадратичная                     | Быстрая сортировка, сортировка слиянием |
| **O(n²)**      | **Квадратичная**            | Время выполнения растет пропорционально<br>квадрату размера входных данных             | Сортировка пузырьком, вставками         |
| **O(2^n)**     | **Экспоненциальная**        | Время выполнения удваивается<br>при увеличении размера входных данных                  | Решение задачи о рюкзаке (brute force)  |
| **O(n!)**      | **Факториальная**           | Время выполнения увеличивается<br>на факториал от размера входных данных               | Полный перебор перестановок             |

# Графическое представление

- **O(1)**: Время выполнения не изменяется с ростом входных данных.
- **O(log n)**: Время выполнения увеличивается медленно, даже для больших n.
- **O(n)**: Линейное увеличение времени с увеличением входных данных.
- **O(n log n)**: Увеличение времени между O(n) и O(n²).
- **O(n²)**: Резкое увеличение времени при росте n.
- **O(2^n)**: Экспоненциальный рост, быстро становится неприемлемым для больших n.

# Примеры алгоритмов с различной сложностью

| О-нотация      | Пример алгоритма                                                |
|----------------|-----------------------------------------------------------------|
| **O(1)**       | Доступ к элементу массива по индексу                            |
| **O(log n)**   | Бинарный поиск в отсортированном массиве                        |
| **O(n)**       | Линейный поиск в неотсортированном массиве                      |
| **O(n log n)** | Быстрая сортировка, сортировка слиянием                         |
| **O(n²)**      | Сортировка пузырьком, вложенные циклы                           |
| **O(2^n)**     | Полный перебор всех возможных решений задачи (например, рюкзак) |
| **O(n!)**      | Полный перебор перестановок                                     |

## Примеры кода с разной сложностью

### O(1) — Константная сложность
```python
def get_first_element(arr):
    return arr[0]
```
Доступ к первому элементу списка выполняется за постоянное время, независимо от длины списка.

### O(n) — Линейная сложность
```python
def find_element(arr, target):
    for item in arr:
        if item == target:
            return True
    return False
```
Здесь мы просматриваем каждый элемент списка, так что время выполнения пропорционально количеству элементов.

### O(log n) — Логарифмическая сложность (пример бинарного поиска)
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return True
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return False
```
Каждое деление массива пополам уменьшает количество элементов в два раза, что приводит к логарифмическому времени выполнения.

### O(n²) — Квадратичная сложность
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```
Здесь два вложенных цикла, каждый из которых зависит от размера списка, что приводит к квадратичной сложности.

# Амортизированная сложность

Иногда сложность оценивается как амортизированная.
Например, добавление элемента в динамический массив обычно выполняется за O(1),
но при увеличении массива операция копирования выполняется за O(n).
Однако, средняя сложность добавления элемента остается O(1) из-за редкости таких операций копирования.

# Резюме

| О-нотация    | Описание                                           |
|--------------|----------------------------------------------------|
| `O(1)`       | Быстро и эффективно, лучший случай                 |
| `O(log n)`   | Очень эффективно для больших наборов данных        |
| `O(n)`       | Умеренно эффективно                                |
| `O(n log n)` | Хорошо для сортировок и некоторых сложных операций |
| `O(n²)`      | Подходит для небольших наборов данных              |
| `O(2^n)`     | Только для очень малых наборов данных              |
| `O(n!)`      | Крайне неэффективно, только для учебных задач      |

# image

![BigONotation.png](General/Terms and Abbreviations/BigONotation.png)
