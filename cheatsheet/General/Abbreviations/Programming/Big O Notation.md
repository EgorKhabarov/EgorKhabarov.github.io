**O-нотация** (Big O Notation) математическая нотация, которая описывает поведение алгоритмов с точки зрения их **асимптотической сложности**
Она используется для оценки времени выполнения и потребляемой памяти в зависимости от размера входных данных

# Важные понятия

- **Размер входных данных (n)**: Количество элементов, которые обрабатывает алгоритм
- **Время выполнения**: Количество операций, выполняемых алгоритмом по мере увеличения входных данных
- **Худший случай**: Сценарий, при котором алгоритм выполняется дольше всего
- **Оценка сверху**: O-нотация всегда показывает верхнюю границу времени выполнения (или использования памяти) алгоритма

# Основные классы сложности

| О-нотация      | Сложность                   | Описание                                                                               | Пример                                  |
|----------------|-----------------------------|----------------------------------------------------------------------------------------|-----------------------------------------|
| **O(1)**       | **Константная**             | Время выполнения не зависит от размера входных данных                                  | Доступ к элементу массива по индексу    |
| **O(log n)**   | **Логарифмическая**         | Время выполнения увеличивается логарифмически<br>по отношению к размеру входных данных | Бинарный поиск                          |
| **O(n)**       | **Линейная**                | Время выполнения растет линейно<br>с увеличением размера входных данных                | Линейный поиск в массиве                |
| **O(n log n)** | **Линейно-логарифмическая** | Увеличивается быстрее, чем O(n),<br>но медленнее, чем квадратичная                     | Быстрая сортировка, сортировка слиянием |
| **O(n²)**      | **Квадратичная**            | Время выполнения растет пропорционально<br>квадрату размера входных данных             | Сортировка пузырьком, вставками         |
| **O(2^n)**     | **Экспоненциальная**        | Время выполнения удваивается<br>при увеличении размера входных данных                  | Решение задачи о рюкзаке (brute force)  |
| **O(n!)**      | **Факториальная**           | Время выполнения увеличивается<br>на факториал от размера входных данных               | Полный перебор перестановок             |

# Графическое представление

- **O(1)**: Время выполнения не изменяется с ростом входных данных
- **O(log n)**: Время выполнения увеличивается медленно, даже для больших n
- **O(n)**: Линейное увеличение времени с увеличением входных данных
- **O(n log n)**: Увеличение времени между O(n) и O(n²)
- **O(n²)**: Резкое увеличение времени при росте n
- **O(2^n)**: Экспоненциальный рост, быстро становится неприемлемым для больших n

# Примеры алгоритмов с различной сложностью

| О-нотация      | Пример алгоритма                                                |
|----------------|-----------------------------------------------------------------|
| **O(1)**       | Доступ к элементу массива по индексу                            |
| **O(log n)**   | Бинарный поиск в отсортированном массиве                        |
| **O(n)**       | Линейный поиск в неотсортированном массиве                      |
| **O(n log n)** | Быстрая сортировка, сортировка слиянием                         |
| **O(n²)**      | Сортировка пузырьком, вложенные циклы                           |
| **O(2^n)**     | Полный перебор всех возможных решений задачи (например, рюкзак) |
| **O(n!)**      | Полный перебор перестановок                                     |

## Примеры кода с разной сложностью

### O(1) Константная сложность
```python
def get_first_element(arr):
    return arr[0]
```
Доступ к первому элементу списка выполняется за постоянное время, независимо от длины списка

### O(n) Линейная сложность
```python
def find_element(arr, target):
    for item in arr:
        if item == target:
            return True
    return False
```
Здесь мы просматриваем каждый элемент списка, так что время выполнения пропорционально количеству элементов

### O(log n) Логарифмическая сложность (пример бинарного поиска)
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return True
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return False
```
Каждое деление массива пополам уменьшает количество элементов в два раза, что приводит к логарифмическому времени выполнения

### O(n²) Квадратичная сложность
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```
Здесь два вложенных цикла, каждый из которых зависит от размера списка, что приводит к квадратичной сложности

# Амортизированная сложность

Иногда сложность оценивается как амортизированная
Например, добавление элемента в динамический массив обычно выполняется за O(1), но при увеличении массива операция копирования выполняется за O(n)
Однако, средняя сложность добавления элемента остается O(1) из-за редкости таких операций копирования

# Резюме

| О-нотация    | Описание                                           |
|--------------|----------------------------------------------------|
| `O(1)`       | Быстро и эффективно, лучший случай                 |
| `O(log n)`   | Очень эффективно для больших наборов данных        |
| `O(n)`       | Умеренно эффективно                                |
| `O(n log n)` | Хорошо для сортировок и некоторых сложных операций |
| `O(n²)`      | Подходит для небольших наборов данных              |
| `O(2^n)`     | Только для очень малых наборов данных              |
| `O(n!)`      | Крайне неэффективно, только для учебных задач      |

# image

![BigONotation.png](General/Abbreviations/Programming/BigONotation.png)
