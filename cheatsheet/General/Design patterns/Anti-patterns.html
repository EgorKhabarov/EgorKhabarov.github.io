<p>Антипаттерн - это распространенный подход к решению часто встречающихся проблем, который может нанести больше вреда, чем пользы</p>
<p><a href="https://ru.wikipedia.org/wiki/Антипаттерн">https://ru.wikipedia.org/wiki/Антипаттерн</a>
<a href="https://habr.com/ru/companies/slurm/articles/706024/">https://habr.com/ru/companies/slurm/articles/706024/</a></p>
<h1>Антипаттерны в объектно-ориентированном программировании</h1>
<h3>Базовый класс-утилита (BaseBean)</h3>
<p>Наследование функциональности из класса-утилиты вместо делегирования к нему</p>
<h3>Anemic Domain Model</h3>
<p>боязнь размещать логику в объектах предметной области</p>
<h3>Вызов предка (Call super)</h3>
<p>Для реализации прикладной функциональности методу класса-потомка требуется в обязательном порядке вызывать те же методы класса-предка</p>
<h3>Ошибка пустого подкласса (Empty subclass failure)</h3>
<p>Создание класса (в Perl), который не проходит «проверку пустоты подкласса» («Empty Subclass Test») из-за различного поведения по сравнению с классом, который наследуется от него без изменений</p>
<h3>Божественный объект (God object)</h3>
<p>Концентрация слишком большого количества функций в одной части системы (классе)</p>
<h3>Объектная клоака (Object cesspool)</h3>
<p>Переиспользование объектов, находящихся в непригодном для переиспользования состоянии</p>
<h3>Полтергейст (Poltergeist)</h3>
<p>Объекты, чьё единственное предназначение - передавать информацию другим объектам</p>
<h3>Проблема йо-йо (Yo-yo problem)</h3>
<p>Чрезмерная размытость сильно связанного кода (например, выполняемого по порядку) по иерархии классов</p>
<h3>Одиночество (Singletonitis)</h3>
<p>Неуместное использование паттерна одиночка синглтон</p>
<h3>Френд-зона (Friend zone)</h3>
<p>Неуместное использование дружественных классов и дружественных функций в языке C++</p>
<h3>Каша из интерфейсов (Interface soup)</h3>
<p>Объединение нескольких интерфейсов, разделенных согласно принципу изоляции интерфейсов (Interface segregation), в один</p>
<h3>Висящие концы</h3>
<p>Интерфейс, большинство методов которого бессмысленны и реализуются «пустышками»</p>
<h3>Заглушка (Stub)</h3>
<p>Попытка «натянуть» на объект уже имеющийся малоподходящий по смыслу интерфейс, вместо создания нового</p>
<h1>Антипаттерны при написании кода</h1>
<h3>Ненужная сложность (Accidental complexity)</h3>
<p>Внесение ненужной сложности в решение</p>
<h3>Действие на расстоянии (Action at a distance)</h3>
<p>Неожиданное взаимодействие между широко разделёнными частями системы</p>
<h3>Накопить и запустить (Accumulate and fire)</h3>
<p>Установка параметров подпрограмм в наборе глобальных переменных</p>
<h3>Слепая вера (Blind faith)</h3>
<p>Недостаточная проверка корректности исправления ошибки или результата работы подпрограммы</p>
<h3>Лодочный якорь (Boat anchor)</h3>
<p>Сохранение более не используемой части системы</p>
<h3>Активное ожидание (Busy spin, busy waiting)</h3>
<p>Потребление ресурсов ЦПУ (процессорного времени) во время ожидания события, обычно при помощи постоянно повторяемой проверки, вместо того, чтобы использовать асинхронное программирование (к примеру, систему сообщений или событий)</p>
<h3>Кэширование ошибки (Caching failure)</h3>
<p>Забывать сбросить флаг ошибки после её обработки</p>
<h3>Воняющий подгузник (The Diaper Pattern Stinks)</h3>
<p>Сброс флага ошибки без её обработки или передачи вышестоящему обработчику</p>
<h3>Проверка типа вместо интерфейса (Checking type instead of membership, Checking type instead of interface)</h3>
<p>Проверка того, что объект имеет специфический тип в то время, когда требуется только определённый интерфейс</p>
<h3>Инерция кода (Code momentum)</h3>
<p>Сверхограничение части системы путём постоянного подразумевания её поведения в других частях системы</p>
<h3>Кодирование путём исключения (Coding by exception)</h3>
<p>Добавление нового кода для поддержки каждого специального распознанного случая</p>
<h3>Таинственный код (Cryptic code)</h3>
<p>Использование аббревиатур вместо мнемоничных имён</p>
<h3>Жёсткое кодирование (Hard code)</h3>
<p>Внедрение предположений об окружении системы в слишком большом количестве точек её реализации</p>
<h3>Мягкое кодирование (Soft code)</h3>
<p>Патологическая боязнь жёсткого кодирования, приводящая к тому, что настраивается всё что угодно, при этом конфигурирование системы само по себе превращается в программирование</p>
<h3>Поток лавы (Lava flow)</h3>
<p>Сохранение нежелательного (излишнего или низкокачественного) кода по причине того, что его удаление слишком дорого или будет иметь непредсказуемые последствия</p>
<h3>Волшебные числа (Magic numbers)</h3>
<p>Использование числовых констант без объяснения их смысла</p>
<h3>Процедурный код (Procedural code)</h3>
<p>Когда другая парадигма является более подходящей</p>
<h3>Спагетти-код (Spaghetti code, иногда «макароны»)</h3>
<p>Код с чрезмерно запутанным порядком выполнения</p>
<h3>Лазанья-код (Lasagnia code, или «лук» (onion))</h3>
<p>Чрезмерное связывание между собой уровней абстракции, приводящее к невозможности изменения одного уровня без изменения остальных</p>
<h3>Равиоли-код (Ravioli code, или «пельмени»)</h3>
<p>Объекты настолько «склеены» между собой, что практически не допускают рефакторинга</p>
<h3>Мыльный пузырь (Soap bubble)</h3>
<p>Объект, инициализированый мусором, максимально долго притворяется, что содержит какие-то данные</p>
<h3>Мьютексный ад (Mutex hell)</h3>
<p>Внедрение слишком большого количества объектов синхронизации между потоками</p>
<h3>(Мета-)шаблонный рак (Template cancer)</h3>
<p>Повсеместное использование шаблонов (в основном C++), в том числе там, где их использование не оправдано
Это уменьшает понимание и сопровождение кода и замедляет компиляцию</p>
<h1>Методологические антипаттерны</h1>
<h3>Программирование методом копирования-вставки (Copy and paste programming)</h3>
<p>Копирование (и лёгкая модификация) существующего кода вместо создания общих решений</p>
<h3>Дефакторинг (De-Factoring)</h3>
<p>Процесс уничтожения функциональности и замены её документацией</p>
<h3>Золотой молоток (Golden hammer)</h3>
<p>Сильная уверенность в том, что любимое решение универсально применимо
Название происходит от поговорки «когда в руках молоток, все проблемы кажутся гвоздями»</p>
<h3>Фактор невероятности (Improbability factor)</h3>
<p>Предположение о невозможности того, что сработает известная ошибка</p>
<h3>Преждевременная оптимизация (Premature optimization)</h3>
<p>Оптимизация на этапе проектирования сегмента кода, приводящая к его усложнению или искажению</p>
<h3>Программирование методом подбора (Programming by permutation)</h3>
<p>Подход к разработке программного обеспечения небольшими изменениями без понимания их смысла</p>
<h3>Изобретение колеса/велосипеда (Reinventing the wheel)</h3>
<p>Создание с нуля вместо использования хорошего готового решения</p>
<h3>Изобретение квадратного колеса (Reinventing the square wheel)</h3>
<p>Создание плохого решения, при условии, что уже существует известное решение лучше</p>
<h3>Самоуничтожение (Self-destruction)</h3>
<p>Фатальная ошибка либо нестандартное поведение программы, приводящая к отказу в обслуживании, возникшая вследствие другой менее серьёзной ошибки. Например, при возникновении ошибки, приложение начинает очень быстро и много писать в лог, вследствие чего заканчивается место на жёстком диске быстрее, чем это обнаружит мониторинг</p>
<h3>Два тоннеля</h3>
<p>Вынесение новой функциональности в отдельное приложение вместо расширения уже имеющегося
Чаще всего применяется, когда по каким-либо причинам (в основном, при нехватке времени либо нежелании менеджмента) внесение изменений в уже имеющийся код требует больших затрат, чем создание нового
При этом у клиента в конечном итоге работают два приложения, запускаясь одновременно либо попеременно друг из друга</p>
<h3>Коммит-убийца (Commit assasin)</h3>
<p>Внесение отдельных изменений в систему контроля версий без проверки влияния их на другие части программы
Как правило, после подобных коммитов работа коллектива парализуется на время исправления проблем в местах, которые ранее работали безошибочно</p>