# Argument types

В Python есть два основных типа аргументов:

## Positional arguments
Позиционные аргументы передаются по порядку
```python
def greet(name: str, age: int):
    print(name, age)

greet("Alice", 20)  # Alice 20
greet(20, "Alice")  # 20 Alice
```
Порядок аргументов важен!

## Keyword arguments
Именованные аргументы передаются с указанием имени
```python
def greet(name: str, age: int):
    print(name, age)

greet(age=20, name="Alice")  # Alice 20
```
Порядок не важен, потому что аргументы указаны по именам

## \*args, **kwargs

- `*args` собирает позиционные аргументы в кортеж
- `**kwargs` собирает именованные аргументы в словарь

```python
def func(a, *args, b, **kwargs):
    print(a)
    print(args)
    print(b)
    print(kwargs)

func(1, 2, 3, x=4, y=5)
# a=1
# args=(2, 3)
# b=4
# kwargs={"c": 5, "d": 6}
```
_b автоматически становится keyword-only, так как он после *args_

## Символы / и * в определении аргументов

Синтаксис объявления аргументов функции в Python можно описать так:
```python
def func(positional_only, /, positional_or_keyword, *, keyword_only):
    ...
```

| Часть                                     | Что значит                                   |
| ----------------------------------------- | -------------------------------------------- |
| `positional_only` (до `/`)                | Можно передавать **только позиционно**       |
| `positional_or_keyword` (между `/` и `*`) | Можно передавать **позиционно или по имени** |
| `keyword_only` (после `*`)                | Можно передавать **только по имени**         |

### Примеры
#### Только позиционные аргументы

```python
def f(a, b, /):
    print(a, b)

f(1, 2)      # OK
f(a=1, b=2)  # TypeError
```

#### Только именованные аргументы

```python
def f(*, a, b):
    print(a, b)

f(a=1, b=2)  # OK
f(1, 2)      # TypeError
```

#### Смешанный вариант

```python
def f(a, b, /, c, *, d):
    print(a, b, c, d)

f(1, 2, 3, d=4)        # OK
f(1, 2, c=3, d=4)      # OK
f(a=1, b=2, c=3, d=4)  # TypeError
```

#### С `*args` и `**kwargs`

```python
def f(a, /, *args, b, **kwargs):
    print(a, args, b, kwargs)

f(1, 2, 3, b=4, x=5)
# a=1
# args=(2, 3)
# b=4
# kwargs={'x': 5}
```

### Правила и ограничения

- `/` можно использовать только один раз и только до `*`
- `*` можно использовать только один раз (если это не `*args`)
- `/` всегда идёт перед `*`
- Аргументы после `*` всегда keyword-only (только по имени)

## Зачем это нужно

- Контроль способа вызова функции
- Совместимость API (можно добавлять новые именованные аргументы без поломки старых вызовов)
- Повышение читаемости и точности сигнатуры функций
