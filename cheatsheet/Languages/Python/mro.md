<h1>Method resolution order | Порядок разрешения методов</h1>
<p>Позволяет Питону выяснить, из какого класса-предка нужно вызывать метод,
если он не обнаружен непосредственно в классе-потомке при множественном наследовании.</p>
<p>Решает проблему <strong>«ромбовидной структуры»</strong> («diamond diagram»).</p>
<div class="code-element">
    <div class="lang-line">
        <text>python</text>
        <button class="copy-button"
        onclick="copyCode(this)">
    <svg stroke="currentColor"
         fill="none"
         stroke-width="2"
         viewBox="0 0 24 24"
         stroke-linecap="round"
         stroke-linejoin="round"
         class="h-4 w-4"
         height="1em"
         width="1em"
         xmlns="http://www.w3.org/2000/svg">
        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
        <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
    </svg>
    <text>Copy code</text>
</button>

    </div>
    <div class="code"><div class="highlight"><pre><span></span><span class="err">⠀</span> <span class="nb">object</span>
   <span class="o">/</span>   \
  <span class="n">A</span>     <span class="n">B</span>
   \   <span class="o">/</span>
     <span class="n">C</span>
</pre></div></div>
</div>

<p><strong>Линеаризация класса</strong> - это список из самого класса и всех его предков (родителей и прародителей)
в котором по порядку слева направо будет производиться поиск метода.</p>
<p><strong>Монотонность</strong> — это свойство, которое требует соблюдения в линеаризации класса-потомка
того же порядка следования классов-прародителей, что и в линеаризации класса-родителя.</p>
<p><strong>Порядок локального старшинства</strong> — это свойство, которое требует соблюдения в линеаризации класса-потомка
того же порядка следования классов-родителей, что и в его объявлении.</p>
<p>Для решения проблемы ромбовидной структуры линеаризация должна быть <strong>монотонной</strong>.</p>
<h1>Алгоритм порядка разрешения методов C3.</h1>
<p>Для достижения указанных выше целей в Питоне используется алгоритм <strong>C3</strong>.</p>
<p><code>[C1, C2, … CN]</code> – список из элементов <code>C1</code>, <code>C2</code>, … <code>CN</code>. Соответственно, <code>[С]</code> — список из одного элемента <code>C</code>.
<code>L[C]</code> – линеаризация класса <code>C</code>. Важно помнить, что любая линеаризация есть список по определению.
<code>merge(L[C1], L[C2], …, L[CN])</code> – объединение элементов линеаризаций <code>L[C1]</code>, <code>L[C2]</code>, …, <code>L[CN]</code> в список с помощью некоторого алгоритма.
По сути, этот алгоритм должен упорядочить все классы из <code>L[C1]</code>, <code>L[C2]</code>, …, <code>L[CN]</code> и исключить дублирование классов в итоговом списке.</p>
<p>Алгоритм C3 представляет из себя набор следующих правил:</p>
<ul>
<li>Линеаризация класса <code>C</code> есть одноэлементный список из самого класса <code>C</code> плюс объединение линеаризаций его родителей и списка всех его родителей.
  В условных обозначениях это можно записать как <code>L[C] = [C] + merge(L[C1], L[C2], …, L[CN], [C1, C2, …, CN])</code>,
  если класс <code>C</code> был объявлен как <code>class C(C1, C2, …, CN)</code>.
  Надо отметить, что каждая линеаризация <code>L[CX]</code> начинается с класса <code>CX</code>,
  который был дополнительно приписан в конец списка объединения как непосредственный родитель класса <code>C</code>.
  Зачем это сделано станет ясно далее.</li>
<li>Объединение линеаризаций происходит следующим образом:<ol>
<li>Берётся нулевой элемент из первой линеаризации <code>L[C1][0]</code>.</li>
<li>Этот элемент ищется во всех других линеаризациях (от <code>L[C2]</code> до <code>L[CN]</code>).</li>
<li>Если этот элемент найден где-то вне начала списка
   (<code>L[CK][X] == L[C1][0]</code>, <code>X != 0</code>; по сути это значит, что <code>L[C1][0]</code> является чьйм-то предком),
   то алгоритм переходит к первому шагу, беря в качестве нулевого элемент из следующей линеаризации (<code>L[C2][0]</code>).</li>
<li>Если элемент нигде не найден в позиции отличной от нулевой, то он добавляется в конец итогового списка линеаризации
   и удаляется из всех рассматриваемых списков (от <code>L[C1]</code> до<code>L[CN]</code>; один и тот же класс не может встречаться в итоговом списке дважды).
   Если после удаления элемента остались пустые списки — они исключаются из объединения.
   После этого алгоритм повторяется с самого начала (от нового элемента L[C1][0]), если он есть.
   Если его нет — объединение закончено.</li>
<li>Если алгоритм дошёл до последнего элемента <code>L[CN]</code>,
   но ни один из нулевых элементов не удовлетворяет правилам, то линеаризация не возможна.</li>
</ol>
</li>
</ul>
<p><a href="https://habr.com/ru/articles/62203/">https://habr.com/ru/articles/62203/</a></p>