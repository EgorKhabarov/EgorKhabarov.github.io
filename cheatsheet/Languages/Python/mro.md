# Method resolution order | Порядок разрешения методов

Позволяет Питону выяснить, из какого класса-предка нужно вызывать метод,
если он не обнаружен непосредственно в классе-потомке при множественном наследовании.

Решает проблему **«ромбовидной структуры»** (**diamond diagram**).

```python
⠀ object
   /   \
  A     B
   \   /
     C
```

**Линеаризация класса** - это список из самого класса и всех его предков (родителей и прародителей)
в котором по порядку слева направо будет производиться поиск метода.

**Монотонность** — это свойство, которое требует соблюдения в линеаризации класса-потомка
того же порядка следования классов-прародителей, что и в линеаризации класса-родителя.

**Порядок локального старшинства** — это свойство, которое требует соблюдения в линеаризации класса-потомка
того же порядка следования классов-родителей, что и в его объявлении.

Для решения проблемы ромбовидной структуры линеаризация должна быть **монотонной**.


# Алгоритм порядка разрешения методов C3.

Для достижения указанных выше целей в Питоне используется алгоритм **C3**.

`[C1, C2, … CN]` – список из элементов `C1`, `C2`, … `CN`. Соответственно, `[С]` — список из одного элемента `C`.
`L[C]` – линеаризация класса `C`. Важно помнить, что любая линеаризация есть список по определению.
`merge(L[C1], L[C2], …, L[CN])` – объединение элементов линеаризаций `L[C1]`, `L[C2]`, …, `L[CN]` в список с помощью некоторого алгоритма.
По сути, этот алгоритм должен упорядочить все классы из `L[C1]`, `L[C2]`, …, `L[CN]` и исключить дублирование классов в итоговом списке.


Алгоритм C3 это набор следующих правил:

- Линеаризация класса `C` есть одноэлементный список из самого класса `C` плюс объединение линеаризаций его родителей и списка всех его родителей.
  В условных обозначениях это можно записать как `L[C] = [C] + merge(L[C1], L[C2], …, L[CN], [C1, C2, …, CN])`,
  если класс `C` был объявлен как `class C(C1, C2, …, CN)`.
  Надо отметить, что каждая линеаризация `L[CX]` начинается с класса `CX`,
  который был дополнительно приписан в конец списка объединения как непосредственный родитель класса `C`.
  Зачем это сделано станет ясно далее.
- Объединение линеаризаций происходит следующим образом:
    1. Берётся нулевой элемент из первой линеаризации `L[C1][0]`.
    2. Этот элемент ищется во всех других линеаризациях (от `L[C2]` до `L[CN]`).
    3. Если этот элемент найден где-то вне начала списка
       (`L[CK][X] == L[C1][0]`, `X != 0`; по сути это значит, что `L[C1][0]` является чьйм-то предком),
       то алгоритм переходит к первому шагу, беря в качестве нулевого элемент из следующей линеаризации (`L[C2][0]`).
    4. Если элемент нигде не найден в позиции отличной от нулевой, то он добавляется в конец итогового списка линеаризации
       и удаляется из всех рассматриваемых списков (от `L[C1]` до` L[CN]`; один и тот же класс не может встречаться в итоговом списке дважды).
       Если после удаления элемента остались пустые списки — они исключаются из объединения.
       После этого алгоритм повторяется с самого начала (от нового элемента `L[C1][0]`), если он есть.
       Если его нет — объединение закончено.
    5. Если алгоритм дошёл до последнего элемента `L[CN]`,
       но ни один из нулевых элементов не удовлетворяет правилам, то линеаризация не возможна.

[https://habr.com/ru/articles/62203/](https://habr.com/ru/articles/62203/)
