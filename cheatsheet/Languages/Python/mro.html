<h1>Method resolution order | Порядок разрешения методов</h1>
<p>Позволяет Питону выяснить, из какого класса-предка нужно вызывать метод,
если он не обнаружен непосредственно в классе-потомке при множественном наследовании.</p>
<p>Решает проблему <strong>«ромбовидной структуры»</strong> («diamond diagram»).</p>
<div class="code_element"><div class="lang_line"><text>python</text><button class="copy_code_button" onclick="CopyCode(this)"><svg style="width: 1.2em;height: 1.2em;" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 4h3a1 1 0 0 1 1 1v15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h3m0 3h6m-5-4v4h4V3h-4Z"/></svg><text class="unselectable">Copy code</text></button></div><div class="code language-python"><div class="highlight"><pre><span></span><span class="err">⠀</span> <span class="nb">object</span>
   <span class="o">/</span>   \
  <span class="n">A</span>     <span class="n">B</span>
   \   <span class="o">/</span>
     <span class="n">C</span>
</pre></div></div></div>

<p><strong>Линеаризация класса</strong> - это список из самого класса и всех его предков (родителей и прародителей)
в котором по порядку слева направо будет производиться поиск метода.</p>
<p><strong>Монотонность</strong> — это свойство, которое требует соблюдения в линеаризации класса-потомка
того же порядка следования классов-прародителей, что и в линеаризации класса-родителя.</p>
<p><strong>Порядок локального старшинства</strong> — это свойство, которое требует соблюдения в линеаризации класса-потомка
того же порядка следования классов-родителей, что и в его объявлении.</p>
<p>Для решения проблемы ромбовидной структуры линеаризация должна быть <strong>монотонной</strong>.</p>
<h1>Алгоритм порядка разрешения методов C3.</h1>
<p>Для достижения указанных выше целей в Питоне используется алгоритм <strong>C3</strong>.</p>
<p><code>[C1, C2, … CN]</code> – список из элементов <code>C1</code>, <code>C2</code>, … <code>CN</code>. Соответственно, <code>[С]</code> — список из одного элемента <code>C</code>.
<code>L[C]</code> – линеаризация класса <code>C</code>. Важно помнить, что любая линеаризация есть список по определению.
<code>merge(L[C1], L[C2], …, L[CN])</code> – объединение элементов линеаризаций <code>L[C1]</code>, <code>L[C2]</code>, …, <code>L[CN]</code> в список с помощью некоторого алгоритма.
По сути, этот алгоритм должен упорядочить все классы из <code>L[C1]</code>, <code>L[C2]</code>, …, <code>L[CN]</code> и исключить дублирование классов в итоговом списке.</p>
<p>Алгоритм C3 представляет из себя набор следующих правил:</p>
<ul>
<li>Линеаризация класса <code>C</code> есть одноэлементный список из самого класса <code>C</code> плюс объединение линеаризаций его родителей и списка всех его родителей.
  В условных обозначениях это можно записать как <code>L[C] = [C] + merge(L[C1], L[C2], …, L[CN], [C1, C2, …, CN])</code>,
  если класс <code>C</code> был объявлен как <code>class C(C1, C2, …, CN)</code>.
  Надо отметить, что каждая линеаризация <code>L[CX]</code> начинается с класса <code>CX</code>,
  который был дополнительно приписан в конец списка объединения как непосредственный родитель класса <code>C</code>.
  Зачем это сделано станет ясно далее.</li>
<li>Объединение линеаризаций происходит следующим образом:<ol>
<li>Берётся нулевой элемент из первой линеаризации <code>L[C1][0]</code>.</li>
<li>Этот элемент ищется во всех других линеаризациях (от <code>L[C2]</code> до <code>L[CN]</code>).</li>
<li>Если этот элемент найден где-то вне начала списка
   (<code>L[CK][X] == L[C1][0]</code>, <code>X != 0</code>; по сути это значит, что <code>L[C1][0]</code> является чьйм-то предком),
   то алгоритм переходит к первому шагу, беря в качестве нулевого элемент из следующей линеаризации (<code>L[C2][0]</code>).</li>
<li>Если элемент нигде не найден в позиции отличной от нулевой, то он добавляется в конец итогового списка линеаризации
   и удаляется из всех рассматриваемых списков (от <code>L[C1]</code> до<code>L[CN]</code>; один и тот же класс не может встречаться в итоговом списке дважды).
   Если после удаления элемента остались пустые списки — они исключаются из объединения.
   После этого алгоритм повторяется с самого начала (от нового элемента L[C1][0]), если он есть.
   Если его нет — объединение закончено.</li>
<li>Если алгоритм дошёл до последнего элемента <code>L[CN]</code>,
   но ни один из нулевых элементов не удовлетворяет правилам, то линеаризация не возможна.</li>
</ol>
</li>
</ul>
<p><a href="https://habr.com/ru/articles/62203/">https://habr.com/ru/articles/62203/</a></p>
