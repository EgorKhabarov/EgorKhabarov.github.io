Библиотека `signal` позволяет работать с сигналами в Unix-подобных операционных системах.
Сигналы — это уведомления, которые операционная система посылает процессам для того,
чтобы сообщить о каких-либо событиях (например, о завершении работы, прерывании и т.д.).

- **Сигнал** — сообщение, посылаемое операционной системой процессу для уведомления о каком-либо событии.
- **Обработчик сигнала** — функция, которая вызывается, когда процесс получает сигнал.

| Сигнал           | Описание                           | Действие по умолчанию |
|------------------|------------------------------------|-----------------------|
| `signal.SIGINT`  | Прерывание (обычно `CTRL+C`)       | Завершение процесса   |
| `signal.SIGTERM` | Завершение процесса                | Завершение процесса   |
| `signal.SIGKILL` | Принудительное завершение процесса | Завершение процесса   |
| `signal.SIGALRM` | Таймер истек                       | Завершение процесса   |
| `signal.SIGHUP`  | Обрыв связи                        | Завершение процесса   |
| `signal.SIGUSR1` | Пользовательский сигнал 1          | Завершение процесса   |
| `signal.SIGUSR2` | Пользовательский сигнал 2          | Завершение процесса   |

> **Примечание:** Сигнал `SIGKILL` нельзя перехватить или игнорировать.

# Установка обработчика сигнала

Для установки обработчика используется функция `signal.signal()`:

```python
def handler(signum, frame):
    print(f"Сигнал {signum} получен")

signal.signal(signal.SIGINT, handler)
```

- `signum`: номер сигнала.
- `frame`: текущее состояние стека (можно игнорировать).

# Игнорирование сигналов

Сигнал можно игнорировать, установив обработчик в `signal.SIG_IGN`:

```python
signal.signal(signal.SIGINT, signal.SIG_IGN)
```

# Восстановление стандартного обработчика

```python
signal.signal(signal.SIGINT, signal.SIG_DFL)
```

# Отправка сигналов процессу

Для отправки сигнала процессу используется функция [[Languages/Python/Libraries/System/os/]]`.kill()`:

```python
import os
os.kill(os.getpid(), signal.SIGTERM)
```

- `os.getpid()` возвращает ID текущего процесса.
- `signal.SIGTERM` — сигнал завершения.

# Работа с таймерами

Функция `signal.alarm()` устанавливает таймер, который отправляет сигнал `SIGALRM` после указанного времени:

```python
signal.alarm(5)  # Через 5 секунд процесс получит сигнал SIGALRM
```

- `signal.alarm(0)` отменяет таймер.

# Ожидание сигнала

Функция `signal.pause()` блокирует выполнение программы до получения сигнала:

```python
signal.pause()  # Ожидание сигнала
```

## Пример использования

```python
import signal
import time

# Обработчик сигнала
def handler(signum, frame):
    print(f"Сигнал {signum} получен. Прерывание программы.")

# Устанавливаем обработчик для SIGINT
signal.signal(signal.SIGINT, handler)

print("Программа работает. Нажмите Ctrl+C для прерывания.")

try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    print("Программа завершена.")

```

Этот пример перехватывает сигнал `SIGINT` (`Ctrl+C`) и выполняет пользовательский обработчик,
который выводит сообщение о получении сигнала.

# Часто используемые функции

| Функция                          | Описание                                                                 |
|----------------------------------|--------------------------------------------------------------------------|
| `signal.signal(signum, handler)` | Устанавливает обработчик для сигнала                                     |
| `signal.getsignal(signum)`       | Возвращает текущий обработчик сигнала                                    |
| `signal.pause()`                 | Останавливает выполнение до получения сигнала                            |
| `signal.alarm(seconds)`          | Устанавливает таймер для отправки сигнала `SIGALRM` через заданное время |
| `signal.setitimer()`             | Устанавливает высокоточный таймер и отправляет сигнал                    |
| `signal.siginterrupt()`          | Устанавливает, должен ли системный вызов быть прерван сигналом           |

## Пример работы с таймером

```python
import signal

def timeout_handler(signum, frame):
    print("Таймер истек!")

# Устанавливаем обработчик для SIGALRM
signal.signal(signal.SIGALRM, timeout_handler)

# Устанавливаем таймер на 5 секунд
signal.alarm(5)

print("Ожидание сигнала...")

# Ожидание сигнала
signal.pause()
```

Этот пример устанавливает таймер на 5 секунд и ждет его истечения.
Когда таймер истекает, вызывается обработчик `timeout_handler`.

## Полезные замечания

1. **Обработчики сигналов**: Старайтесь минимизировать выполнение кода в обработчиках сигналов,
так как они могут быть вызваны в любой момент, что может привести к непредсказуемому поведению.
2. **Портируемость**: Библиотека `signal` доступна только в Unix-подобных системах (Linux, macOS).
На Windows поддерживаются лишь некоторые функции, такие как `signal.SIGINT`.
3. **Сигналы и потоки**: Сигналы обрабатываются в главном потоке. Если ваш процесс использует несколько потоков,
убедитесь, что обработка сигналов не нарушает работу приложения.
