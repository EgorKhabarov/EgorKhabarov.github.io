<h1>tuple</h1>
<table>
<thead>
<tr>
<th>Метод(ы)</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td>tuple<code>.count</code>(value)</td>
<td>Возвращает количество вхождений <code>value</code> в кортеже<br><code>(1, 2, 2, 3).count(2) == 2</code></td>
</tr>
<tr>
<td>tuple<code>.index</code>(value, [start, [stop]])</td>
<td>Возвращает индекс первого вхождения <code>value</code> в кортеже<br>начиная с <code>start</code> и заканчивая <code>stop</code><br>Вызывает ошибку <code>ValueError</code>, если элемент не найден<br><code>(1, 2, 3).index(2)</code><br><code>(1, 2, 3, 2).index(2, 2)</code></td>
</tr>
<tr>
<td>tuple<code>.__add__</code>(other) <code>+</code></td>
<td>Возвращает новый кортеж являющийся результатом<br>конкатенации текущего кортежа и <code>other</code><br><code>(1, 2) + (3, 4) == (1, 2, 3, 4)</code></td>
</tr>
<tr>
<td>tuple<code>.__mul__</code>(n) <code>*</code></td>
<td>Возвращает новый кортеж, состоящий<br>из <code>n</code> повторений текущего кортежа<br><code>(1, 2) * 3 == (1, 2, 1, 2, 1, 2)</code></td>
</tr>
<tr>
<td>tuple<code>.__rmul__</code>(n) <code>*</code></td>
<td>Аналогично <code>__mul__</code>, вызывается при <code>n * tuple</code><br><code>3 * (1, 2) == (1, 2, 1, 2, 1, 2)</code></td>
</tr>
<tr>
<td>tuple<code>.__eq__</code>(other) <code>&#61;&#61;</code></td>
<td><code>(1, 2) == (1, 2)</code></td>
</tr>
<tr>
<td>tuple<code>.__ne__</code>(other) <code>!=</code></td>
<td><code>(1, 2) != (3, 4)</code></td>
</tr>
<tr>
<td>tuple<code>.__lt__</code>(other) <code>&lt;</code></td>
<td><code>(1, 2) &lt; (1, 3)</code></td>
</tr>
<tr>
<td>tuple<code>.__le__</code>(other) <code>&lt;=</code></td>
<td><code>(1, 2) &lt;= (1, 2)</code></td>
</tr>
<tr>
<td>tuple<code>.__gt__</code>(other) <code>&gt;</code></td>
<td><code>(1, 3) &gt; (1, 2)</code></td>
</tr>
<tr>
<td>tuple<code>.__ge__</code>(other) <code>&gt;=</code></td>
<td><code>(1, 2) &gt;= (1, 1)</code></td>
</tr>
</tbody>
</table>