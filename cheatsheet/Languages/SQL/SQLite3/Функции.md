Функции:

|           |                                                                                                                                                                                                                                                                                                                                                |
|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| MAX       | Возвращает максимальное значение из списка аргументов.<br>может использоваться с числовыми и дата/время типами данных.<br>`SELECT MAX(amount) FROM sales;`                                                                                                                                                                                     |
| MIN       | Возвращает минимальное значение из списка аргументов.<br>может использоваться с числовыми и дата/время типами данных.<br>`SELECT MIN(amount) FROM sales;`                                                                                                                                                                                      |
| SUM       | Возвращает сумму аргументов.<br>может использоваться только с числовыми типами данных.<br>`SELECT SUM(amount) FROM sales;`                                                                                                                                                                                                                     |
| AVG       | Возвращает среднее арифметическое аргументов.<br>может использоваться только с числовыми типами данных.<br>`SELECT AVG(amount) FROM sales;`                                                                                                                                                                                                    |
| COUNT     | Возвращает количество аргументов.<br>может использоваться с различными типами данных.<br>`SELECT COUNT(amount) FROM sales;`                                                                                                                                                                                                                    |
| CONCAT    | Соединяет строки.<br>может использоваться с типом данных строка.<br>`SELECT CONCAT(first_name, ' ', last_name) as full_name FROM customers;`                                                                                                                                                                                                   |
| UPPER     | Преобразует строку в верхний регистр.<br>может использоваться с типом данных строка.<br>`SELECT UPPER(first_name) as first_name, UPPER(last_name) as last_name FROM customers;`                                                                                                                                                                |
| LOWER     | Преобразует строку в нижний регистр.<br>может использоваться с типом данных строка.<br>`SELECT LOWER(first_name) as first_name, LOWER(last_name) as last_name FROM customers;`                                                                                                                                                                 |
| SUBSTR    | Извлекает подстроку из строки. (столбец, первый символ, количество символов)<br>может использоваться с типом данных строка.<br>`SELECT SUBSTR(phone, 1, 3) as area_code FROM customers;`                                                                                                                                                       |
| TRIM      | Удаляет пробелы из начала и конца строки.<br>может использоваться с типом данных строка.<br>`SELECT TRIM(first_name) as first_name, last_name FROM customers;`                                                                                                                                                                                 |
| LENGTH    | Возвращает количество символов в строке.<br>может использоваться с типом данных строка.<br>`SELECT first_name, LENGTH(first_name) as name_length FROM customers;`                                                                                                                                                                              |
| ROUND     | Округляет число до указанной точности. (столбец, кол-во знаков после запятой)<br>может использоваться с типом данных число.<br>`SELECT product, ROUND(price, 2) as price FROM sales;`                                                                                                                                                          |
| DATE      | Преобразует строку в формат даты. (хз проверить на питоне надо)<br>может использоваться с типом данных строка и возвращает тип данных дата.<br>`SELECT DATE(order_date) as order_date, product, price FROM orders;`                                                                                                                            |
| TIME      | Преобразует строку в формат времени. (хз проверить на питоне надо)<br>может использоваться с типом данных строка и возвращает тип данных время.<br>`SELECT TIME(meeting_time) as meeting_time, topic FROM meetings;`                                                                                                                           |
| DATETIME  | Преобразует строку в формат даты и времени.<br>может использоваться с типом данных строка и возвращает тип данных дата/время.<br>`SELECT DATETIME(event_date_time) as event_date_time, event_name FROM events;`                                                                                                                                |
| TIMESTAMP | Преобразует строку в формат времени с меткой времени (timestamp). <br>может использоваться с типом данных строка и возвращает тип данных timestamp.<br>`SELECT TIMESTAMP(log_timestamp) as log_timestamp, log_message FROM logs;`                                                                                                              |
| NOW       | Возвращает текущую дату и время.<br>не требует аргументов и возвращает тип данных timestamp.<br>`INSERT INTO orders (order_date, product, price) VALUES (NOW(), 'Shoes', 59.99);`                                                                                                                                                              |
| COALESCE  | Принимает неограниченное количество аргументов и возвращает первый ненулевой аргумент (???)<br>может использоваться с типами данных число, строка, дата/время и возвращает тип данных, соответствующий первому ненулевому аргументу.<br>`SELECT first_name, last_name, COALESCE(email, '') as email, COALESCE(phone, '') as phone FROM users;` |
| ISNULL    | Проверяет, является ли значение нулевым (NULL).<br>принимает один аргумент и возвращает логическое значение true, если аргумент равен NULL, и false, если аргумент не равен NULL.<br>`SELECT first_name, last_name, position FROM employees WHERE ISNULL(bonus);`                                                                              |
| IFNULL    | Проверяет, является ли значение нулевым (NULL).<br>принимает два аргумента и возвращает первый аргумент, если он не равен NULL, и второй аргумент, если первый равен NULL.<br>`SELECT name, price, IFNULL(description, 'No description') as description FROM products;`                                                                        |

CASE - позволяет условно выполнять различные действия в запросе SQL.
       состоит из секций WHEN, THEN и ELSE, где WHEN указывает условие,
       THEN - действие, которое нужно выполнить при выполнении условия,
       а ELSE - действие, которое нужно выполнить, если условие не выполнено.
       SELECT position, salary,
       CASE
       WHEN salary > 40000 THEN 'High salary'
       WHEN salary BETWEEN 30000 AND 40000 THEN 'Average salary'
       ELSE 'Low salary'
       END as salary_level
       FROM employees;

IIF (IF ELSE) - позволяет условно выполнять различные действия в запросе SQL.
                принимает три аргумента: логическое выражение, возвращаемое значение при истинном условии и возвращаемое значение при ложном условии.
```sql
SELECT name, price, IIF(quantity > 0, 'In stock', 'Out of stock') as stock_status FROM products;
```

ROW_NUMBER - используется для нумерации строк в результирующем наборе данных.
             используется совместно с оператором ORDER BY для сортировки строк по определенному критерию.
```sql
SELECT ROW_NUMBER() OVER (ORDER BY quantity) as row_num, product_name, quantity, price FROM sales;
```

RANK - используется для нумерации строк в результирующем наборе данных.
       используется совместно с оператором ORDER BY для сортировки строк по определенному критерию.
       (Отличие RANK от ROW_NUMBER заключается в том, что RANK нумерует строки с учетом их значений.
        Например, если у нас есть несколько строк с одинаковым значением, то RANK будет устанавливать им ранг
        с учетом этого одинакового значения, а не просто нумеровать их в порядке возрастания.)
       (Обратите внимание, что если бы у нас были строки с одинаковым значением количества, то они бы получили одинаковый ранг.)
```sql
SELECT RANK() OVER (ORDER BY quantity) as row_num, product_name, quantity, price FROM sales;
```

DENSE_RANK - используется для нумерации строк в результирующем наборе данных.
             используется совместно с оператором ORDER BY для сортировки строк по определенному критерию.
             (Отличие DENSE_RANK от RANK заключается в том, что DENSE_RANK нумерует строки с учетом их значений,
              но не оставляет промежутки между рангами. Таким образом, если у нас есть несколько строк с одинаковым значением,
              то DENSE_RANK будет устанавливать им ранг с учетом этого одинакового значения, но не оставляет промежутки между рангами.)
             (Обратите внимание, что если бы у нас были строки с одинаковым значением количества, то они бы получили одинаковый ранг.
              Отличие от RANK заключается в том, что DENSE_RANK не оставляет промежутки между рангами.)
```sql
SELECT DENSE_RANK() OVER (ORDER BY quantity) as row_num, product_name, quantity, price FROM sales;
```

NTILE - используется для разбиения результирующего набора данных на равные части.
        используется совместно с оператором ORDER BY для сортировки строк по определенному критерию.
        (разбить эту таблицу на 3 равные части и пронумеровать каждую строку с учетом ее нахождения в этой части)
```sql
SELECT NTILE(3) OVER (ORDER BY quantity) as group_num, product_name, quantity, price FROM sales;
```

LAG - используется для получения значения из предыдущей строки результирующего набора данных.
      используется для сравнения значений в разных строках или для вычисления разницы между значениями.
      (получить таблицу с колонкой, содержащей разницу между ценой текущей строки и ценой предыдущей строки.)
```sql
SELECT product_name, price, LAG(price, 1) OVER (ORDER BY date) as prev_price, price - LAG(price, 1) OVER (ORDER BY date) as price_diff FROM sales;
```

LEAD - используется для получения значения из следующей строки результирующего набора данных.
       используется для сравнения значений в разных строках или для вычисления разницы между значениями.
       SELECT product_name, price, LEAD(price, 1) OVER (ORDER BY date) as next_price, price - LEAD(price, 1) OVER (ORDER BY date) as price_diff FROM sales;
       (получить таблицу с колонкой, содержащей разницу между ценой текущей строки и ценой следующей строки.)

EXPLAIN - используется для анализа плана выполнения запроса.
          возвращает таблицу с информацией о том, как база данных планирует выполнить запрос, включая информацию о том,
          какие таблицы и столбцы будут использоваться, какие индексы будут использоваться, и как будут объединяться таблицы.
          EXPLAIN SELECT * FROM sales WHERE price > 200;
          (Мы хотим анализировать план выполнения запроса на выборку всех строк таблицы "sales" с ценой больше 200.)


EXPLAIN ANALYZE - расширение функции EXPLAIN, включает в себя дополнительную информацию о времени выполнения каждого этапа плана выполнения запроса.
                  Эта информация может быть полезна при оптимизации запросов и изучении причин медленного выполнения.
                  EXPLAIN ANALYZE SELECT * FROM sales WHERE price > 200;
                  (Каждая строка таблицы описывает один этап плана и содержит следующие столбцы:
                   Номер этапа
                   Тип этапа (поиск, сортировка, табулирование и т.п.)
                   Таблицы, на которые распространяется действие этапа
                   Количество строк, которое будет обработано на этом этапе
                   Время выполнения этапа)
                  (Например, таблица может выглядеть следующим образом:
                   Seq.    Type    Table    Rows    Time
                   1    scan    sales    3        0.001
                   2    sort            3        0.002
                   3    limit            3        0.002)
                  (Основное отличие между EXPLAIN и EXPLAIN ANALYZE заключается в том, что EXPLAIN ANALYZE не только выводит информацию о плане выполнения запроса,
                   но и РЕАЛЬНО выполняет запрос и возвращает результат. Это позволяет получить более точную информацию о времени выполнения каждого этапа,
                   так как используется реальное время выполнения, а не оценочные данные, которые могут быть предоставлены функцией EXPLAIN.
                   Также EXPLAIN ANALYZE может показать дополнительную информацию, такую как количество сканированных строк, общее время выполнения запроса и т.п.)

ABS (абсолютное значение) - возвращает абсолютное значение указанного числа. ABS(-5) = 5, ABS(3) = 3

ACOS (арккосинус) - возвращает арккосинус указанного числа. Арккосинус - это угол, косинус которого равен указанному числу.
                    Функция ACOS может принимать любое число в диапазоне от -1 до 1, включительно, и возвращает угол в радианах.
                    ACOS(0.5) = 1.0471975511966, ACOS(-1) = 3.14159265358979

ASIN (арксинус) - возвращает арксинус указанного числа.
                  Арксинус - это угол, синус которого равен указанному числу.
                  Функция ASIN может принимать любое число в диапазоне от -1 до 1, включительно, и возвращает угол в радианах.
                  ASIN(0.5) = 0.52359877559829
                  ASIN(-1) = -1.5707963267949
                  Функция ASIN может быть использована для вычисления угла в треугольнике, если известны два катета и гипотенуза. Для этого нужно воспользоваться теоремой синусов.

ATAN (арктангенс) - возвращает арктангенс указанного числа.
                    Арктангенс - это угол, тангенс которого равен указанному числу.
                    Функция ATAN может принимать любое число и возвращает угол в радианах.
                    ATAN(1) = 0.78539816339745
                    ATAN(-2) = -1.10714871779409
                    Функция ATAN может быть использована для вычисления угла в треугольнике, если известны два катета и гипотенуза. Для этого нужно воспользоваться теоремой тангенсов.
                    (Пример использования функции ATAN в SQL запросе:
                     SELECT ATAN(2) as atan FROM DUAL;
                     Этот запрос выполнится и вернет арктангенс числа 2, то есть 1.10714871779409.
                     Также функция ATAN может быть использована в качестве условия в WHERE клаузе, например:
                     SELECT * FROM points WHERE ATAN(y/x) > 0.5;
                     В этом запросе будут выбраны точки, у которых угол между осью X и вектором из начала координат до точки больше 0.5 радиан.)

ATAN2 (арктангенс 2) - возвращает арктангенс указанной точки (y, x).
                       Арктангенс - это угол, тангенс которого равен указанной точке.
                       Функция ATAN2 принимает два аргумента - y и x, и возвращает угол в радианах.
                       ATAN2(1, 1) = 0.78539816339745
                       ATAN2(-2, 2) = -0.78539816339745
                       Функция ATAN2 может быть использована для вычисления угла в треугольнике, если известны два катета и гипотенуза.
                       Для этого нужно воспользоваться теоремой тангенсов.
                       (Отличие между функциями ATAN и ATAN2 в том, что ATAN принимает только один аргумент - тангенс угла,
                        в то время как ATAN2 принимает два аргумента - координаты точки в декартовой системе координат.
                        Это позволяет ATAN2 вычислять угол даже если одна из координат равна нулю, чего не может сделать функция ATAN.)

CEIL (от ceiling)   возвращает наименьшее целое число, которое больше или равно переданному значению. CEIL(3.14) вернет 4, а CEIL(-3.14) вернет -3.
COS                 возвращает косинус угла в градусах. COS(угол в градусах) COS(45) result 0.7071067811865475
COT                 возвращает котангенс угла в радианах. Котангенс угла равен обратному тангенсу угла. COT(угол в радианах) COT(PI() / 4) result 1
                    функция COT работает так же, как и функция SIN и TAN, но ожидает угол в радианах.

DEGREES             преобразует радианы в градусы. DEGREES(выражение_вычисляется_как_радианы) DEGREES(PI()) result 180
EXP                 возвращает экспоненту (е в степени) заданного числа. EXP(выражение_вычисляется_как_число) EXP(2) result 7.38905609893065
                    число e (естественный логарифм) равно 2.718281828459045. EXP(2) эквивалентно e^2 = 7.38905609893065.
FLOOR               возвращает наибольшее целое число, которое меньше или равно переданному значению. FLOOR(выражение_вычисляется_как_число) FLOOR(3.14) result 3
                    FLOOR отличается от CEIL тем, что возвращает наибольшее целое число, которое меньше или равно переданному значению,
                    в то время как CEIL возвращает наименьшее целое число, которое больше или равно переданному значению.

LN                  возвращает натуральный логарифм (по основанию e) заданного числа. LN(выражение_вычисляется_как_число) LN(2)сresult 0.693147180559945
                    число e (естественный логарифм) равно 2.718281828459045. LN(2) эквивалентно ln(2) = 0.693147180559945.

LOG                 возвращает логарифм заданного числа по заданному основанию. LOG(выражение_вычисляется_как_число, основание_логарифма) LOG(100, 10) result 2
                    работает так же, как и функция LN, но позволяет задавать основание логарифма. LOG(100, 10) эквивалентно log10(100) = 2.

LOG10               возвращает десятичный логарифм числа. LOG10(выражение, которое вычисляется как число) LOG10(100) result 2
                    всегда возвращает положительное число. Если входное число 0 или отрицательно, то результатом будет NULL.

MOD                 возвращает остаток от деления одного числа на другое. MOD(10, 3) result 1
                    всегда возвращает положительное число. Если второе число равно 0, то результатом будет NULL.

PI                  возвращает значение математической константы Пи (3.14159265358979323846)  PI() result 3.141592653589793
POWER               возвращает результат возведения числа в степень. POWER(основание_степени, показатель_степени) POWER(2, 3) result 8  эквивалентно выражению 2^3 = 8.
RADIANS             преобразует градусы в радианы. RADIANS(угол в градусах)  угол в 180 градусов равен PI радианам (3.141592653589793)
RAND                которая возвращает случайное число в диапазоне от 0 до 1. RAND()  Результат: 0.5298371105
SIGN                возвращает 1, 0 или -1 в зависимости от того, положительное, нулевое или отрицательное число соответственно.SIGN(выражение, которое вычисляется как число)
SIN                 возвращает синус угла в радианах. SIN(угол в радианах)
SQRT                возвращает квадратный корень числа. всегда возвращает неотрицательный квадратный корень.
                    Если вы хотите вернуть квадратный корень с отрицательным числом, то результатом будет NULL.

TAN                 возвращает тангенс угла в радианах. TAN(угол в радианах)


[https://www.sqlite.org/json1.html#jex](https://www.sqlite.org/json1.html#jex)

| Функция / Оператор                    | Описание                                                                                   | Пример использования                                                                 |
|---------------------------------------|--------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|
| JSON(json)                            | Преобразует строку в формат JSON                                                           | JSON('{"name": "John", "age": 30}')<br>{"name":"John","age":30}                      |
| JSONB(json)                           | `JSON`, но в бинарном формате<br>для более эффективного доступа                            | JSONB('{"name": "John", "age": 30}')                                                 |
| JSON_ARRAY(value1, value2, ...)       | Создает JSON массив из переданных аргументов                                               | JSON_ARRAY('apple', 'banana', 'cherry')<br>["apple","banana","cherry"]               |
| JSONB_ARRAY(value1, value2, ...)      | `JSON_ARRAY`, но в бинарном формате                                                        | JSONB_ARRAY('apple', 'banana', 'cherry')                                             |
| JSON_ARRAY_LENGTH(json, [path])       | Возвращает количество элементов<br>в массиве                                               | JSON_ARRAY_LENGTH('["apple", "banana", "cherry"]')<br>3<br>JSON_ARRAY_LENGTH('["apple", "banana", "cherry"]', '$')<br>3<br>JSON_ARRAY_LENGTH('{"fruits": ["apple", "banana", "cherry"]}', '$.fruits')<br>3      |
| JSON_ERROR_POSITION(json)             | Возвращает позицию ошибки в JSON строке,<br>если JSON недействителен                       | JSON_ERROR_POSITION('{"name": "John", "age": 30,}')                                  |
| JSON_EXTRACT(json, path, ...)         | Извлекает значение по заданному пути                                                       | JSON_EXTRACT('{"name": "John", "age": 30}', '$.name')<br>John                        |
| JSONB_EXTRACT(json, path, ...)        | `JSON_EXTRACT`, но работает с бинарными JSON данными                                       | JSONB_EXTRACT('{"name": "John", "age": 30}', '$.name')                               |
| json -> path                          | Извлекает значение по заданному пути<br>`JSON_EXTRACT`                                     | '{"name": "John", "age": 30}' -> '$.name'<br>John                                    |
| json ->> path                         | Извлекает значение по заданному пути<br>и преобразует его в текст<br>`JSON_EXTRACT`        | '{"name": "John", "age": 30}' ->> '$.name'<br>John                                   |
| JSON_INSERT(json, path, value, ...)   | Вставляет новое значение по заданному пути                                                 | JSON_INSERT('{"name": "John"}', '$.age', 30)<br>{"name":"John","age":30}             |
| JSONB_INSERT(json, path, value, ...)  | `JSON_INSERT`, но с бинарными JSON данными                                                 | JSONB_INSERT('{"name": "John"}', '$.age', 30)                                        |
| JSON_OBJECT(label1, value1, ...)      | Создает JSON объект из пар "ключ-значение"                                                 | JSON_OBJECT('name', 'John', 'age', 30)<br>{"name":"John","age":30}                   |
| JSONB_OBJECT(label1, value1, ...)     | `JSON_OBJECT`, но в бинарном формате                                                       | JSONB_OBJECT('name', 'John', 'age', 30)                                              |
| JSON_PATCH(json1, json2)              | Объединяет два JSON<br>значения из второго документа<br>перезаписывают значения из первого | JSON_PATCH('{"name": "John"}', '{"age": 30}')<br>{"name":"John","age":30}            |
| JSONB_PATCH(json1, json2)             | `JSON_PATCH`, но с бинарными JSON данными                                                  | JSONB_PATCH('{"name": "John"}', '{"age": 30}')                                       |
| JSON_PRETTY(json)                     | Форматирует JSON для более удобного чтения                                                 | JSON_PRETTY('{"name": "John", "age": 30}')                                           |
| JSON_REMOVE(json, path, ...)          | Удаляет значение по заданному пути                                                         | JSON_REMOVE('{"name": "John", "age": 30}', '$.age')<br>{"name":"John"}               |
| JSONB_REMOVE(json, path, ...)         | `JSON_REMOVE`, но с бинарными JSON данными                                                 | JSONB_REMOVE('{"name": "John", "age": 30}', '$.age')                                 |
| JSON_REPLACE(json, path, value, ...)  | Заменяет значение в JSON документе<br>по заданному пути (если путь существует)             | JSON_REPLACE('{"name": "John", "age": 30}', '$.age', 31)<br>{"name":"John","age":31} |
| JSONB_REPLACE(json, path, value ,...) | `JSON_REPLACE`, но с бинарными JSON данными                                                | JSONB_REPLACE('{"name": "John", "age": 30}', '$.age', 31)                            |
| JSON_SET(json, path, value, ...)      | Устанавливает значение по заданному пути                                                   | JSON_SET('{"name": "John", "age": 30}', '$.age', 31)<br>{"name":"John","age":31}     |
| JSONB_SET(json, path, value, ...)     | `JSON_SET`, но с бинарными JSON данными                                                    | JSONB_SET('{"name": "John", "age": 30}', '$.age', 31)                                |
| JSON_TYPE(json, [path])               | Возвращает тип значения<br>по заданному пути в JSON документе                              | JSON_TYPE('{"name": "John", "age": 30}')<br>object<br>JSON_TYPE('{"name": "John", "age": 30}', '$')<br>object<br>JSON_TYPE('{"name": "John", "age": 30}', '$.name')<br>text                           |
| JSON_VALID(json)                      | Проверяет, является ли строка<br>допустимым JSON документом                                | JSON_VALID('{"name": "John", "age": 30}')<br>1                                       |
| JSON_VALID(json, flags)               | `JSON_VALID`, но с флагами для проверки                                                    | JSON_VALID('{"name": "John", "age": 30}', 0)                                         |
| JSON_QUOTE(value)                     | Кавычит значение для включения в JSON документ                                             | JSON_QUOTE('John')<br>"John"                                                         |
