<h1>SQLite Функции</h1>
<h2>JSON</h2>
<p><a href="https://www.sqlite.org/json1.html#jex">https://www.sqlite.org/json1.html#jex</a></p>
<table>
<thead>
<tr>
<th>Функция / Оператор</th>
<th>Описание</th>
<th>Пример использования</th>
</tr>
</thead>
<tbody>
<tr>
<td>JSON(json)</td>
<td>Преобразует строку в формат JSON</td>
<td><code>JSON('{"name": "John", "age": 30}')</code><br>{"name":"John","age":30}</td>
</tr>
<tr>
<td>JSONB(json)</td>
<td><code>JSON</code>, но в бинарном формате<br>для более эффективного доступа</td>
<td><code>JSONB('{"name": "John", "age": 30}')</code></td>
</tr>
<tr>
<td>JSON_ARRAY(value1, value2, ...)</td>
<td>Создает JSON массив из переданных аргументов</td>
<td><code>JSON_ARRAY('apple', 'banana', 'cherry')</code><br>["apple","banana","cherry"]</td>
</tr>
<tr>
<td>JSONB_ARRAY(value1, value2, ...)</td>
<td><code>JSON_ARRAY</code>, но в бинарном формате</td>
<td><code>JSONB_ARRAY('apple', 'banana', 'cherry')</code></td>
</tr>
<tr>
<td>JSON_ARRAY_LENGTH(json, [path])</td>
<td>Возвращает количество элементов<br>в массиве</td>
<td><code>JSON_ARRAY_LENGTH('\["apple", "banana", "cherry"]')</code><br>3<br><code>JSON_ARRAY_LENGTH('\["apple", "banana", "cherry"]', '$')</code><br>3<br><code>JSON_ARRAY_LENGTH('{"fruits": \["apple", "banana", "cherry"]}', '$.fruits')</code><br>3</td>
</tr>
<tr>
<td>JSON_ERROR_POSITION(json)</td>
<td>Возвращает позицию ошибки в JSON строке,<br>если JSON недействителен</td>
<td><code>JSON_ERROR_POSITION('{"name": "John", "age": 30,}')</code></td>
</tr>
<tr>
<td>JSON_EXTRACT(json, path, ...)</td>
<td>Извлекает значение по заданному пути</td>
<td><code>JSON_EXTRACT('{"name": "John", "age": 30}', '$.name')</code><br>John</td>
</tr>
<tr>
<td>JSONB_EXTRACT(json, path, ...)</td>
<td><code>JSON_EXTRACT</code>, но работает с бинарными JSON данными</td>
<td><code>JSONB_EXTRACT('{"name": "John", "age": 30}', '$.name')</code></td>
</tr>
<tr>
<td>json -&gt; path</td>
<td>Извлекает значение по заданному пути<br><code>JSON_EXTRACT</code></td>
<td><code>'{"name": "John", "age": 30}' -&gt; '$.name'</code><br>John</td>
</tr>
<tr>
<td>json -&gt;&gt; path</td>
<td>Извлекает значение по заданному пути<br>и преобразует его в текст<br><code>JSON_EXTRACT</code></td>
<td><code>'{"name": "John", "age": 30}' -&gt;&gt; '$.name'</code><br>John</td>
</tr>
<tr>
<td>JSON_INSERT(json, path, value, ...)</td>
<td>Вставляет новое значение по заданному пути</td>
<td><code>JSON_INSERT('{"name": "John"}', '$.age', 30)</code><br>{"name":"John","age":30}</td>
</tr>
<tr>
<td>JSONB_INSERT(json, path, value, ...)</td>
<td><code>JSON_INSERT</code>, но с бинарными JSON данными</td>
<td><code>JSONB_INSERT('{"name": "John"}', '$.age', 30)</code></td>
</tr>
<tr>
<td>JSON_OBJECT(label1, value1, ...)</td>
<td>Создает JSON объект из пар "ключ-значение"</td>
<td><code>JSON_OBJECT('name', 'John', 'age', 30)</code><br>{"name":"John","age":30}</td>
</tr>
<tr>
<td>JSONB_OBJECT(label1, value1, ...)</td>
<td><code>JSON_OBJECT</code>, но в бинарном формате</td>
<td><code>JSONB_OBJECT('name', 'John', 'age', 30)</code></td>
</tr>
<tr>
<td>JSON_PATCH(json1, json2)</td>
<td>Объединяет два JSON<br>значения из второго документа<br>перезаписывают значения из первого</td>
<td><code>JSON_PATCH('{"name": "John"}', '{"age": 30}')</code><br>{"name":"John","age":30}</td>
</tr>
<tr>
<td>JSONB_PATCH(json1, json2)</td>
<td><code>JSON_PATCH</code>, но с бинарными JSON данными</td>
<td><code>JSONB_PATCH('{"name": "John"}', '{"age": 30}')</code></td>
</tr>
<tr>
<td>JSON_PRETTY(json)</td>
<td>Форматирует JSON для более удобного чтения</td>
<td><code>JSON_PRETTY('{"name": "John", "age": 30}')</code></td>
</tr>
<tr>
<td>JSON_REMOVE(json, path, ...)</td>
<td>Удаляет значение по заданному пути</td>
<td><code>JSON_REMOVE('{"name": "John", "age": 30}', '$.age')</code><br>{"name":"John"}</td>
</tr>
<tr>
<td>JSONB_REMOVE(json, path, ...)</td>
<td><code>JSON_REMOVE</code>, но с бинарными JSON данными</td>
<td><code>JSONB_REMOVE('{"name": "John", "age": 30}', '$.age')</code></td>
</tr>
<tr>
<td>JSON_REPLACE(json, path, value, ...)</td>
<td>Заменяет значение в JSON документе<br>по заданному пути (если путь существует)</td>
<td><code>JSON_REPLACE('{"name": "John", "age": 30}', '$.age', 31)</code><br>{"name":"John","age":31}</td>
</tr>
<tr>
<td>JSONB_REPLACE(json, path, value ,...)</td>
<td><code>JSON_REPLACE</code>, но с бинарными JSON данными</td>
<td><code>JSONB_REPLACE('{"name": "John", "age": 30}', '$.age', 31)</code></td>
</tr>
<tr>
<td>JSON_SET(json, path, value, ...)</td>
<td>Устанавливает значение по заданному пути</td>
<td><code>JSON_SET('{"name": "John", "age": 30}', '$.age', 31)</code><br>{"name":"John","age":31}</td>
</tr>
<tr>
<td>JSONB_SET(json, path, value, ...)</td>
<td><code>JSON_SET</code>, но с бинарными JSON данными</td>
<td><code>JSONB_SET('{"name": "John", "age": 30}', '$.age', 31)</code></td>
</tr>
<tr>
<td>JSON_TYPE(json, [path])</td>
<td>Возвращает тип значения<br>по заданному пути в JSON документе</td>
<td><code>JSON_TYPE('{"name": "John", "age": 30}')</code><br>object<br><code>JSON_TYPE('{"name": "John", "age": 30}', '$')</code><br>object<br><code>JSON_TYPE('{"name": "John", "age": 30}', '$.name')</code><br>text</td>
</tr>
<tr>
<td>JSON_VALID(json)</td>
<td>Проверяет, является ли строка<br>допустимым JSON документом</td>
<td><code>JSON_VALID('{"name": "John", "age": 30}')</code><br>1</td>
</tr>
<tr>
<td>JSON_VALID(json, flags)</td>
<td><code>JSON_VALID</code>, но с флагами для проверки</td>
<td><code>JSON_VALID('{"name": "John", "age": 30}', 0)</code></td>
</tr>
<tr>
<td>JSON_QUOTE(value)</td>
<td>Кавычит значение для включения в JSON документ</td>
<td><code>JSON_QUOTE('John')</code><br>"John"</td>
</tr>
</tbody>
</table>
<h1>Функции</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MAX</code></td>
<td>Возвращает максимальное значение из списка аргументов.<br>может использоваться с числовыми и дата/время типами данных<br><code>SELECT MAX(amount) FROM sales;</code></td>
</tr>
<tr>
<td><code>MIN</code></td>
<td>Возвращает минимальное значение из списка аргументов.<br>может использоваться с числовыми и дата/время типами данных<br><code>SELECT MIN(amount) FROM sales;</code></td>
</tr>
<tr>
<td><code>SUM</code></td>
<td>Возвращает сумму аргументов.<br>может использоваться только с числовыми типами данных<br><code>SELECT SUM(amount) FROM sales;</code></td>
</tr>
<tr>
<td><code>AVG</code></td>
<td>Возвращает среднее арифметическое аргументов.<br>может использоваться только с числовыми типами данных<br><code>SELECT AVG(amount) FROM sales;</code></td>
</tr>
<tr>
<td><code>COUNT</code></td>
<td>Возвращает количество аргументов.<br>может использоваться с различными типами данных<br><code>SELECT COUNT(amount) FROM sales;</code></td>
</tr>
<tr>
<td><code>CONCAT</code></td>
<td>Соединяет строки.<br>может использоваться с типом данных строка<br><code>SELECT CONCAT(first_name, ' ', last_name) as full_name FROM customers;</code></td>
</tr>
<tr>
<td><code>UPPER</code></td>
<td>Преобразует строку в верхний регистр.<br>может использоваться с типом данных строка<br><code>SELECT UPPER(first_name) as first_name, UPPER(last_name) as last_name FROM customers;</code></td>
</tr>
<tr>
<td><code>LOWER</code></td>
<td>Преобразует строку в нижний регистр.<br>может использоваться с типом данных строка<br><code>SELECT LOWER(first_name) as first_name, LOWER(last_name) as last_name FROM customers;</code></td>
</tr>
<tr>
<td><code>SUBSTR</code></td>
<td>Извлекает подстроку из строки. (столбец, первый символ, количество символов)<br>может использоваться с типом данных строка<br><code>SELECT SUBSTR(phone, 1, 3) as area_code FROM customers;</code></td>
</tr>
<tr>
<td><code>TRIM</code></td>
<td>Удаляет пробелы из начала и конца строки.<br>может использоваться с типом данных строка<br><code>SELECT TRIM(first_name) as first_name, last_name FROM customers;</code></td>
</tr>
<tr>
<td><code>LENGTH</code></td>
<td>Возвращает количество символов в строке.<br>может использоваться с типом данных строка<br><code>SELECT first_name, LENGTH(first_name) as name_length FROM customers;</code></td>
</tr>
<tr>
<td><code>ROUND</code></td>
<td>Округляет число до указанной точности. (столбец, кол-во знаков после запятой)<br>может использоваться с типом данных число<br><code>SELECT product, ROUND(price, 2) as price FROM sales;</code></td>
</tr>
<tr>
<td><code>DATE</code></td>
<td>Преобразует строку в формат даты. (хз проверить на питоне надо)<br>может использоваться с типом данных строка и возвращает тип данных дата<br><code>SELECT DATE(order_date) as order_date, product, price FROM orders;</code></td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>Преобразует строку в формат времени. (хз проверить на питоне надо)<br>может использоваться с типом данных строка и возвращает тип данных время<br><code>SELECT TIME(meeting_time) as meeting_time, topic FROM meetings;</code></td>
</tr>
<tr>
<td><code>DATETIME</code></td>
<td>Преобразует строку в формат даты и времени.<br>может использоваться с типом данных строка и возвращает тип данных дата/время<br><code>SELECT DATETIME(event_date_time) as event_date_time, event_name FROM events;</code></td>
</tr>
<tr>
<td><code>TIMESTAMP</code></td>
<td>Преобразует строку в формат времени с меткой времени (<code>timestamp</code>). <br>может использоваться с типом данных строка и возвращает тип данных <code>timestamp</code><br><code>SELECT TIMESTAMP(log_timestamp) as log_timestamp, log_message FROM logs;</code></td>
</tr>
<tr>
<td><code>NOW</code></td>
<td>Возвращает текущую дату и время.<br>не требует аргументов и возвращает тип данных <code>timestamp</code><br><code>INSERT INTO orders (order_date, product, price) VALUES (NOW(), 'Shoes', 59.99);</code></td>
</tr>
<tr>
<td><code>COALESCE</code></td>
<td>Принимает неограниченное количество аргументов и возвращает первый ненулевой аргумент (???)<br>может использоваться с типами данных число, строка, дата/время и возвращает тип данных, соответствующий первому ненулевому аргументу<br><code>SELECT first_name, last_name, COALESCE(email, '') as email, COALESCE(phone, '') as phone FROM users;</code></td>
</tr>
<tr>
<td><code>ISNULL</code></td>
<td>Проверяет, является ли значение нулевым (<code>NULL</code>).<br>принимает один аргумент и возвращает логическое значение <code>true</code>, если аргумент равен <code>NULL</code>, и <code>false</code>, если аргумент не равен <code>NULL</code><br><code>SELECT first_name, last_name, position FROM employees WHERE ISNULL(bonus);</code></td>
</tr>
<tr>
<td><code>IFNULL</code></td>
<td>Проверяет, является ли значение нулевым (<code>NULL</code>).<br>принимает два аргумента и возвращает первый аргумент, если он не равен <code>NULL</code>, и второй аргумент, если первый равен <code>NULL</code><br><code>SELECT name, price, IFNULL(description, 'No description') as description FROM products;</code></td>
</tr>
</tbody>
</table>
<h2>CASE</h2>
<p>Позволяет условно выполнять различные действия в запросе SQL
Состоит из секций <code>WHEN</code>, <code>THEN</code> и <code>ELSE</code>, где <code>WHEN</code> указывает условие,
<code>THEN</code> - действие, которое нужно выполнить при выполнении условия,
а <code>ELSE</code> - действие, которое нужно выполнить, если условие не выполнено</p>
<div class="code_element"><div class="lang_line"><text>sql</text><button class="copy_code_button" onclick="CopyCode(this)"><svg width="1.2em" height="1.2em" viewBox="0 0 24 24"><use href="#icon_code_copy"/></svg><text class="unselectable">Copy code</text></button></div><div class="code language-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">position</span><span class="k">,</span>
<span class="w">       </span><span class="n">salary</span><span class="k">,</span>
<span class="w">       </span><span class="k">CASE</span>
<span class="w">           </span><span class="k">WHEN</span><span class="w"> </span><span class="n">salary</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">40000</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="s1">&#39;High salary&#39;</span>
<span class="w">           </span><span class="k">WHEN</span><span class="w"> </span><span class="n">salary</span><span class="w"> </span><span class="k">BETWEEN</span><span class="w"> </span><span class="mi">30000</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="mi">40000</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="s1">&#39;Average salary&#39;</span>
<span class="w">           </span><span class="k">ELSE</span><span class="w"> </span><span class="s1">&#39;Low salary&#39;</span>
<span class="w">       </span><span class="k">END</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">salary_level</span>
<span class="w">  </span><span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="p">;</span>
</pre></div></div></div>

<h2>IIF (IF ELSE)</h2>
<p>Позволяет условно выполнять различные действия в запросе SQL
Принимает три аргумента: логическое выражение, возвращаемое значение при истинном условии
и возвращаемое значение при ложном условии</p>
<div class="code_element"><div class="lang_line"><text>sql</text><button class="copy_code_button" onclick="CopyCode(this)"><svg width="1.2em" height="1.2em" viewBox="0 0 24 24"><use href="#icon_code_copy"/></svg><text class="unselectable">Copy code</text></button></div><div class="code language-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="k">,</span>
<span class="w">       </span><span class="n">price</span><span class="k">,</span>
<span class="w">       </span><span class="n">IIF</span><span class="p">(</span><span class="n">quantity</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="k">,</span><span class="w"> </span><span class="s1">&#39;In stock&#39;</span><span class="k">,</span><span class="w"> </span><span class="s1">&#39;Out of stock&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">stock_status</span>
<span class="w">  </span><span class="k">FROM</span><span class="w"> </span><span class="n">products</span><span class="p">;</span>
</pre></div></div></div>

<h2>ROW_NUMBER</h2>
<p>Используется для нумерации строк в результирующем наборе данных
Используется совместно с оператором <code>ORDER BY</code> для сортировки строк по определенному критерию</p>
<div class="code_element"><div class="lang_line"><text>sql</text><button class="copy_code_button" onclick="CopyCode(this)"><svg width="1.2em" height="1.2em" viewBox="0 0 24 24"><use href="#icon_code_copy"/></svg><text class="unselectable">Copy code</text></button></div><div class="code language-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">ROW_NUMBER</span><span class="p">()</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">quantity</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">row_num</span><span class="k">,</span>
<span class="w">       </span><span class="n">product_name</span><span class="k">,</span>
<span class="w">       </span><span class="n">quantity</span><span class="k">,</span>
<span class="w">       </span><span class="n">price</span>
<span class="w">  </span><span class="k">FROM</span><span class="w"> </span><span class="n">sales</span><span class="p">;</span>
</pre></div></div></div>

<h2>RANK</h2>
<p>Используется для нумерации строк в результирующем наборе данных
Используется совместно с оператором <code>ORDER BY</code> для сортировки строк по определенному критерию
Отличие <code>RANK</code> от <code>ROW_NUMBER</code> заключается в том, что <code>RANK</code> нумерует строки с учетом их значений
Например, если у нас есть несколько строк с одинаковым значением, то <code>RANK</code> будет устанавливать им ранг
с учетом этого одинакового значения, а не просто нумеровать их в порядке возрастания</p>
<p>Обратите внимание, что если бы у нас были строки с одинаковым значением количества, то они бы получили одинаковый ранг</p>
<div class="code_element"><div class="lang_line"><text>sql</text><button class="copy_code_button" onclick="CopyCode(this)"><svg width="1.2em" height="1.2em" viewBox="0 0 24 24"><use href="#icon_code_copy"/></svg><text class="unselectable">Copy code</text></button></div><div class="code language-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">RANK</span><span class="p">()</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">quantity</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">row_num</span><span class="k">,</span>
<span class="w">       </span><span class="n">product_name</span><span class="k">,</span>
<span class="w">       </span><span class="n">quantity</span><span class="k">,</span>
<span class="w">       </span><span class="n">price</span>
<span class="w">  </span><span class="k">FROM</span><span class="w"> </span><span class="n">sales</span><span class="p">;</span>
</pre></div></div></div>

<h2>DENSE_RANK</h2>
<p>Используется для нумерации строк в результирующем наборе данных
Используется совместно с оператором <code>ORDER BY</code> для сортировки строк по определенному критерию
Отличие <code>DENSE_RANK</code> от <code>RANK</code> заключается в том, что <code>DENSE_RANK</code> нумерует строки с учетом их значений,
но не оставляет промежутки между рангами
Таким образом, если у нас есть несколько строк с одинаковым значением,
то <code>DENSE_RANK</code> будет устанавливать им ранг с учетом этого одинакового значения, но не оставляет промежутки между рангами</p>
<p>Обратите внимание, что если бы у нас были строки с одинаковым значением количества, то они бы получили одинаковый ранг
Отличие от <code>RANK</code> заключается в том, что <code>DENSE_RANK</code> не оставляет промежутки между рангами</p>
<div class="code_element"><div class="lang_line"><text>sql</text><button class="copy_code_button" onclick="CopyCode(this)"><svg width="1.2em" height="1.2em" viewBox="0 0 24 24"><use href="#icon_code_copy"/></svg><text class="unselectable">Copy code</text></button></div><div class="code language-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">DENSE_RANK</span><span class="p">()</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">quantity</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">row_num</span><span class="k">,</span>
<span class="w">       </span><span class="n">product_name</span><span class="k">,</span>
<span class="w">       </span><span class="n">quantity</span><span class="k">,</span>
<span class="w">       </span><span class="n">price</span>
<span class="w">  </span><span class="k">FROM</span><span class="w"> </span><span class="n">sales</span><span class="p">;</span>
</pre></div></div></div>

<h2>NTILE</h2>
<p>Используется для разбиения результирующего набора данных на равные части
Используется совместно с оператором <code>ORDER BY</code> для сортировки строк по определенному критерию
Разбить эту таблицу на 3 равные части и пронумеровать каждую строку с учетом ее нахождения в этой части</p>
<div class="code_element"><div class="lang_line"><text>sql</text><button class="copy_code_button" onclick="CopyCode(this)"><svg width="1.2em" height="1.2em" viewBox="0 0 24 24"><use href="#icon_code_copy"/></svg><text class="unselectable">Copy code</text></button></div><div class="code language-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">NTILE</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">quantity</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">group_num</span><span class="k">,</span>
<span class="w">       </span><span class="n">product_name</span><span class="k">,</span>
<span class="w">       </span><span class="n">quantity</span><span class="k">,</span>
<span class="w">       </span><span class="n">price</span>
<span class="w">  </span><span class="k">FROM</span><span class="w"> </span><span class="n">sales</span><span class="p">;</span>
</pre></div></div></div>

<h2>LAG</h2>
<p>Используется для получения значения из предыдущей строки результирующего набора данных
Используется для сравнения значений в разных строках или для вычисления разницы между значениями
Получить таблицу с колонкой, содержащей разницу между ценой текущей строки и ценой предыдущей строки</p>
<div class="code_element"><div class="lang_line"><text>sql</text><button class="copy_code_button" onclick="CopyCode(this)"><svg width="1.2em" height="1.2em" viewBox="0 0 24 24"><use href="#icon_code_copy"/></svg><text class="unselectable">Copy code</text></button></div><div class="code language-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">product_name</span><span class="k">,</span>
<span class="w">       </span><span class="n">price</span><span class="k">,</span>
<span class="w">       </span><span class="n">LAG</span><span class="p">(</span><span class="n">price</span><span class="k">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="nb">date</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">prev_price</span><span class="k">,</span>
<span class="w">       </span><span class="n">price</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">LAG</span><span class="p">(</span><span class="n">price</span><span class="k">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="nb">date</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">price_diff</span>
<span class="w">  </span><span class="k">FROM</span><span class="w"> </span><span class="n">sales</span><span class="p">;</span>
</pre></div></div></div>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EXPLAIN</code></td>
<td>Используется для анализа плана выполнения запроса<br>Возвращает таблицу с информацией о том, как база данных планирует выполнить запрос, включая информацию о том,<br>какие таблицы и столбцы будут использоваться, какие индексы будут использоваться, и как будут объединяться таблицы<br><code>EXPLAIN SELECT * FROM sales WHERE price &gt; 200;</code><br>Мы хотим анализировать план выполнения запроса на выборку всех строк таблицы <code>sales</code> с ценой больше <code>200</code></td>
</tr>
<tr>
<td><code>EXPLAIN ANALYZE</code></td>
<td>Расширение функции <code>EXPLAIN</code>, включает в себя дополнительную информацию о времени выполнения каждого этапа плана выполнения запроса<br>Эта информация может быть полезна при оптимизации запросов и изучении причин медленного выполнения<br><code>EXPLAIN ANALYZE SELECT * FROM sales WHERE price &gt; 200;</code><br>(Каждая строка таблицы описывает один этап плана и содержит следующие столбцы:<br>Номер этапа<br>Тип этапа (поиск, сортировка, табулирование и т.п.)<br>Таблицы, на которые распространяется действие этапа<br>Количество строк, которое будет обработано на этом этапе<br>Время выполнения этапа)<br>Например, таблица может выглядеть следующим образом:<br>&vert; Seq &vert; Type  &vert; Table &vert; Rows &vert; Time  &vert;<br>&vert;-----&vert;-------&vert;-------&vert;------&vert;-------&vert;<br>&vert; 1   &vert; scan  &vert; sales &vert; 3    &vert; 0.001 &vert;<br>&vert; 2   &vert; sort  &vert;       &vert; 3    &vert; 0.002 &vert;<br>&vert; 3   &vert; limit &vert;       &vert; 3    &vert; 0.002 &vert;<br>Основное отличие между <code>EXPLAIN</code> и <code>EXPLAIN ANALYZE</code> заключается в том,<br>что <code>EXPLAIN ANALYZE</code> не только выводит информацию о плане выполнения запроса,<br>но и РЕАЛЬНО выполняет запрос и возвращает результат<br>Это позволяет получить более точную информацию о времени выполнения каждого этапа,<br>так как используется реальное время выполнения,<br>а не оценочные данные, которые могут быть предоставлены функцией <code>EXPLAIN</code><br>Также <code>EXPLAIN ANALYZE</code> может показать дополнительную информацию,<br>такую как количество сканированных строк, общее время выполнения запроса и т.п.)</td>
</tr>
<tr>
<td><code>LEAD</code></td>
<td>Используется для получения значения из следующей строки результирующего набора данных<br>используется для сравнения значений в разных строках или для вычисления разницы между значениями<br><code>SELECT product_name, price, LEAD(price, 1) OVER (ORDER BY date) as next_price,</code><br><code>price - LEAD(price, 1) OVER (ORDER BY date) as price_diff FROM sales;</code><br>(получить таблицу с колонкой, содержащей разницу между ценой текущей строки и ценой следующей строки)</td>
</tr>
<tr>
<td><code>ABS</code> (абсолютное значение)</td>
<td>Возвращает абсолютное значение указанного числа<br><code>ABS(-5) = 5</code>, <code>ABS(3) = 3</code></td>
</tr>
<tr>
<td><code>ACOS</code> (арккосинус)</td>
<td>Возвращает арккосинус указанного числа<br>Арккосинус - это угол, косинус которого равен указанному числу<br>Функция <code>ACOS</code> может принимать любое число в диапазоне от <code>-1</code> до <code>1</code>, включительно, и возвращает угол в радианах<br><code>ACOS(0.5) = 1.0471975511966</code>, <code>ACOS(-1) = 3.14159265358979</code></td>
</tr>
<tr>
<td><code>ASIN</code> (арксинус)</td>
<td>Возвращает арксинус указанного числа<br>Арксинус - это угол, синус которого равен указанному числу<br>Функция <code>ASIN</code> может принимать любое число в диапазоне от -1 до 1, включительно, и возвращает угол в радианах<br><code>ASIN(0.5) = 0.52359877559829</code><br><code>ASIN(-1) = -1.5707963267949</code><br>Функция <code>ASIN</code> может быть использована для вычисления угла в треугольнике, если известны два катета и гипотенуза<br>Для этого нужно воспользоваться теоремой синусов</td>
</tr>
<tr>
<td><code>ATAN</code> (арктангенс)</td>
<td>Возвращает арктангенс указанного числа<br>Арктангенс - это угол, тангенс которого равен указанному числу<br>Функция <code>ATAN</code> может принимать любое число и возвращает угол в радианах<br><code>ATAN(1) = 0.78539816339745</code><br><code>ATAN(-2) = -1.10714871779409</code><br>Функция <code>ATAN</code> может быть использована для вычисления угла в треугольнике, если известны два катета и гипотенуза<br>Для этого нужно воспользоваться теоремой тангенсов<br>(Пример использования функции <code>ATAN</code> в SQL запросе:<br><code>SELECT ATAN(2) as atan FROM DUAL;</code><br>Этот запрос выполнится и вернет арктангенс числа 2, то есть <code>1.10714871779409</code><br>Также функция <code>ATAN</code> может быть использована в качестве условия в <code>WHERE</code> клаузе, например:<br><code>SELECT * FROM points WHERE ATAN(y/x) &gt; 0.5;</code><br>В этом запросе будут выбраны точки, у которых угол между осью <code>X</code> и вектором из начала координат до точки больше <code>0.5</code> радиан)</td>
</tr>
<tr>
<td><code>ATAN2</code> (арктангенс 2)</td>
<td>Возвращает арктангенс указанной точки <code>(y, x)</code><br>Арктангенс - это угол, тангенс которого равен указанной точке<br>Функция <code>ATAN2</code> принимает два аргумента - y и x, и возвращает угол в радианах<br><code>ATAN2(1, 1) = 0.78539816339745</code><br><code>ATAN2(-2, 2) = -0.78539816339745</code><br>Функция <code>ATAN2</code> может быть использована для вычисления угла в треугольнике, если известны два катета и гипотенуза<br>Для этого нужно воспользоваться теоремой тангенсов<br>(Отличие между функциями <code>ATAN</code> и <code>ATAN2</code> в том, что <code>ATAN</code> принимает только один аргумент - тангенс угла,<br>в то время как <code>ATAN2</code> принимает два аргумента - координаты точки в декартовой системе координат<br>Это позволяет <code>ATAN2</code> вычислять угол даже если одна из координат равна нулю, чего не может сделать функция <code>ATAN</code>)</td>
</tr>
<tr>
<td><code>DEGREES</code></td>
<td>Преобразует радианы в градусы<br><code>DEGREES(выражение_вычисляется_как_радианы)</code> <code>DEGREES(PI())</code><br><code>result 180</code></td>
</tr>
<tr>
<td><code>EXP</code></td>
<td>Возвращает экспоненту (<code>е</code> в степени) заданного числа<br><code>EXP(выражение_вычисляется_как_число)</code> <code>EXP(2)</code><br><code>result 7.38905609893065</code><br>Число <code>e</code> (естественный логарифм) равно <code>2.718281828459045</code><br><code>EXP(2)</code> эквивалентно <code>e^2 = 7.38905609893065</code></td>
</tr>
<tr>
<td><code>FLOOR</code></td>
<td>Возвращает наибольшее целое число, которое меньше или равно переданному значению<br><code>FLOOR(выражение_вычисляется_как_число)</code> <code>FLOOR(3.14)</code> <code>result 3</code><br><code>FLOOR</code> отличается от <code>CEIL</code> тем, что возвращает наибольшее целое число, которое меньше или равно переданному значению,<br>в то время как <code>CEIL</code> возвращает наименьшее целое число, которое больше или равно переданному значению</td>
</tr>
<tr>
<td><code>LN</code></td>
<td>Возвращает натуральный логарифм (по основанию e) заданного числа<br><code>LN(выражение_вычисляется_как_число)</code> <code>LN(2)</code> с <code>result 0.693147180559945</code><br>Число <code>e</code> (естественный логарифм) равно <code>2.718281828459045</code><br><code>LN(2)</code> эквивалентно <code>LN(2) = 0.693147180559945</code></td>
</tr>
<tr>
<td><code>LOG</code></td>
<td>Возвращает логарифм заданного числа по заданному основанию<br><code>LOG(выражение_вычисляется_как_число, основание_логарифма)</code> <code>LOG(100, 10)</code> <code>result 2</code><br>работает так же, как и функция <code>LN</code>, но позволяет задавать основание логарифма<br><code>LOG(100, 10)</code> эквивалентно <code>log10(100) = 2</code></td>
</tr>
<tr>
<td><code>LOG10</code></td>
<td>Возвращает десятичный логарифм числа. <code>LOG10(выражение, которое вычисляется как число)</code> <code>LOG10(100)</code> <code>result 2</code><br>всегда возвращает положительное число. Если входное число 0 или отрицательно, то результатом будет <code>NULL</code></td>
</tr>
<tr>
<td><code>MOD</code></td>
<td>Возвращает остаток от деления одного числа на другое<br><code>MOD(10, 3)</code> <code>result 1</code><br>всегда возвращает положительное число. Если второе число равно <code>0</code>, то результатом будет <code>NULL</code></td>
</tr>
<tr>
<td><code>PI</code></td>
<td>Возвращает значение математической константы Пи (<code>3.14159265358979323846</code>) <code>PI()</code> <code>result 3.141592653589793</code></td>
</tr>
<tr>
<td><code>POWER</code></td>
<td>Возвращает результат возведения числа в степень<br><code>POWER(основание_степени, показатель_степени)</code> <code>POWER(2, 3)</code> <code>result 8</code> Эквивалентно выражению <code>2^3 = 8</code></td>
</tr>
<tr>
<td><code>RADIANS</code></td>
<td>Преобразует градусы в радианы<br><code>RADIANS(угол в градусах)</code> угол в <code>180</code> градусов равен <code>PI</code> радианам (<code>3.141592653589793</code>)</td>
</tr>
<tr>
<td><code>RAND</code></td>
<td>Которая возвращает случайное число в диапазоне от <code>0</code> до <code>1</code><br><code>RAND()</code> <code>Результат: 0.5298371105</code></td>
</tr>
<tr>
<td><code>SIGN</code></td>
<td>Возвращает <code>1</code>, <code>0</code> или <code>-1</code> в зависимости от того, положительное, нулевое или отрицательное число соответственно<br><code>SIGN(выражение, которое вычисляется как число)</code></td>
</tr>
<tr>
<td><code>SIN</code></td>
<td>Возвращает синус угла в радианах<br><code>SIN(угол в радианах)</code></td>
</tr>
<tr>
<td><code>SQRT</code></td>
<td>Возвращает квадратный корень числа<br>Всегда возвращает неотрицательный квадратный корень<br>Если вы хотите вернуть квадратный корень с отрицательным числом, то результатом будет <code>NULL</code></td>
</tr>
<tr>
<td><code>TAN</code></td>
<td>Возвращает тангенс угла в радианах<br><code>TAN(угол в радианах)</code></td>
</tr>
<tr>
<td><code>CEIL</code> (от ceiling)</td>
<td>Возвращает наименьшее целое число, которое больше или равно переданному значению<br><code>CEIL(3.14)</code> вернет <code>4</code>, а <code>CEIL(-3.14)</code> вернет <code>-3</code></td>
</tr>
<tr>
<td><code>COS</code></td>
<td>Возвращает косинус угла в градусах<br><code>COS(угол в градусах)</code> <code>COS(45)</code> <code>result 0.7071067811865475</code></td>
</tr>
<tr>
<td><code>COT</code></td>
<td>Возвращает котангенс угла в радианах<br>Котангенс угла равен обратному тангенсу угла<br><code>COT(угол в радианах)</code> <code>COT(PI() / 4)</code> <code>result 1</code><br>Функция <code>COT</code> работает так же, как и функция <code>SIN</code> и <code>TAN</code>, но ожидает угол в радианах.</td>
</tr>
</tbody>
</table>