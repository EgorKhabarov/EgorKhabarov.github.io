# Числовые типы

| Имя              | Размер     | Описание                                  | Диапазон                                              |
|------------------|------------|-------------------------------------------|-------------------------------------------------------|
| smallint         | 2 байта    | Целое в небольшом диапазоне               | -32768 .. +32767                                      |
| integer          | 4 байта    | Типичный выбор для целых чисел            | -2147483648 .. +2147483647                            |
| bigint           | 8 байт     | Целое в большом диапазоне                 | -9223372036854775808 .. 9223372036854775807           |
| decimal          | переменный | Вещественное число с указанной точностью  | до 131072 цифр до десятичной точки и до 16383 — после |
| numeric          | переменный | Вещественное число с указанной точностью  | до 131072 цифр до десятичной точки и до 16383 — после |
| real             | 4 байта    | Вещественное число с переменной точностью | точность в пределах 6 десятичных цифр                 |
| double precision | 8 байт     | Вещественное число с переменной точностью | точность в пределах 15 десятичных цифр                |
| smallserial      | 2 байта    | Небольшое целое с автоувеличением         | 1 .. 32767                                            |
| serial           | 4 байта    | Целое с автоувеличением                   | 1 .. 2147483647                                       |
| bigserial        | 8 байт     | Большое целое с автоувеличением           | 1 .. 9223372036854775807                              |

`numeric` стоит использовать для различных "денежных" вещей, где недопустимо "потерять копейку на округлениях":

```sql
SELECT 3.1415926::real;
--     3.1415925 - чуток потеряли
SELECT 3.1415926::numeric;
--     3.1415926 - а тут все четко
```

`serial`-псевдотипы (аналог `AUTO_INCREMENT / IDENTITY` из других СУБД),
Позволяют определить поля с автоматически формируемым возрастающим значением "по умолчанию": `1, 2, 3, ...`

Нет `unsigned` - все числовые типы знаковые, поэтому "честно" положить диапазон `[0x00000000..0xFFFFFFFF]` в `integer` не получится,
только со смещением "наполовину"

# Символьные типы

| Имя                                 | Описание                                               |
|-------------------------------------|--------------------------------------------------------|
| character varying(n), varchar(n)    | Строка ограниченной переменной длины                   |
| character(n), char(n), bpchar(n)    | Строка фиксированной длины, дополненная пробелами      |
| bpchar                              | Строка неограниченной переменной длины с удалением пробелов |
| text                                | Строка неограниченной переменной длины                 |

Указание ограничения длины не дает никаких бонусов.
За исключением случаев, когда вам действительно требуется ограничить длину записываемого в поле
Например, для 2-буквенного кода страны.

# Типы даты/времени

[Дата и время](https://postgrespro.ru/docs/postgresql/16/datatype-datetime) в `PostgreSQL`, технически, хранятся как целочисленные,
со значением от [POSTGRES_EPOCH](https://github.com/postgres/postgres/blob/871fe4917e1e92304bdcc2ab779de7416492c6de/src/include/datatype/timestamp.h#L235)(01.01.2000) в соответствующих единицах (микросекундах или сутках):

| Имя                                 | Размер  | Описание                               | Наименьшее значение | Наибольшее значение | Точность       |
|-------------------------------------|---------|----------------------------------------|---------------------|---------------------|----------------|
| timestamp [(p)] [without time zone] | 8 байт  | Дата и время (без часового пояса)      | 4713 до н. э        | 294276 н. э         | 1 микросекунда |
| timestamp [(p)] with time zone      | 8 байт  | Дата и время (с часовым поясом)        | 4713 до н. э        | 294276 н. э         | 1 микросекунда |
| date                                | 4 байта | Дата (без времени суток)               | 4713 до н. э        | 5874897 н. э        | 1 день         |
| time [(p)] [without time zone]      | 8 байт  | Время суток (без даты)                 | 00:00:00            | 24:00:00            | 1 микросекунда |
| time [(p)] with time zone           | 12 байт | Время дня (без даты), с часовым поясом | 00:00:00+1559       | 24:00:00-1559       | 1 микросекунда |
| interval [ поля ] [(p)]             | 16 байт | Временной интервал                     | -178000000 лет      | 178000000 лет       | 1 микросекунда |

В этом их отличие от некоторых других СУБД, где  может храниться как текстовая строка.

Арифметические операции как над числами над `timestamp` тоже допустимы, в том числе преобразование к Unix time (время от `01.01.1970`)

```sql
SELECT '2024-01-01'::date - 1;
-- 2023-12-31 - за день до
SELECT '2024-01-01'::date - 8 * '1 hour'::interval;
-- 2023-12-31 16:00:00 - за 8 часов до
SELECT extract(epoch from '2024-01-01'::timestamp);
-- 1704067200 - превратили timestamp в double precision
SELECT '1970-01-01 00:00:00'::timestamp + 1704067200 * '1 second'::interval;
-- 2024-01-01 00:00:00 - ... и обратно
```

Во временном значении можно использовать часовой пояс `with time zone`
или указывать сохраняемую точность (`timestamp(0)` означает хранение "до секунд").

# Логический тип

| Имя     | Размер | Описание                   |
|---------|--------|----------------------------|
| boolean | 1 байт | Состояние: истина или ложь |

Он может принимать значения `TRUE`/`FALSE` и `NULL`, равно как и любой другой тип.


# Специальные типы данных

Помимо базовых типов, "из коробки" `PostgreSQL` предоставляет массу других, более специализированных, типов:

- двоичные данные
- перечисления
- геометрические
- сетевые адреса
- битовые строки
- вектора текстового поиска
- UUID
- XML
- JSON
- массивы
- диапазоны

Например, всякие картографические сервисы любят использовать [геометрические типы](https://postgrespro.ru/docs/postgresql/16/datatype-geometric) данных с расширением `PostGIS`,
а слабоструктурированные данные можно хранить в [JSON](https://postgrespro.ru/docs/postgresql/16/datatype-json), причем ничуть не хуже какой-нибудь `MongoDB`,
а идентификаторы в распределенных системах - в [UUID](https://postgrespro.ru/docs/postgresql/16/datatype-uuid).

Если вдруг и этих типов вам окажется мало – можно [создать свой](https://postgrespro.ru/docs/postgresql/16/sql-createtype) и работать с ним как с любым другим полем.
Главное, правильно его описать, задать соответствующие функции ввода-вывода, хранения и обработки.

Вообще, PostgreSQL очень хорошо расширяем, поэтому `EXTENSION`'ы, которые для него можно найти и подключить,
составляют достаточно весомую часть его преимуществ по отношению к другим СУБД.
