&& (И)
|| (ИЛИ)
! (НЕ)

Если необходимо проверить несколько условий в одном операторе, то можно воспользоваться логическим «и» или же логическим «или»:

```cpp
if (a != b && a > b) {
    // Код будет выполнен, если и первое, и второе условие
    // окажутся верными
}

if (a < b || a == b) {
    // Код будет выполнен, если или первое, или второе условие
    // окажется верным
}
```

Тернарная операция
Это сокращенная форма if else
Записывается следующим образом:

```cpp
int x = 90, a = 8;
int res = x < a ? (x + a) : (x - a);
cout << res << endl;
```

Проверяем: если “x” будет меньше “а”, то в переменную res устанавливаем их сумму, иначе – их разницу

Конструкция switch
Конструкция case обладает более удобным форматом для проверки множественных условий на совпадение значения
В конструкцию записывается переменная, что проверяется, а также значения на которые происходит проверка

Пример оператора:

```cpp
int x = 23;
switch (x) { // Проверяем переменную x
    case 1: // Если переменная будет равна 1, то здесь сработает код
        // Может быть множество строк, а не только одна
        cout << "Переменная равна 1" << endl;
        break; // Указываем конец для кода для этой проверки
    case 56: // Если переменная будет равна 56, то здесь сработает код
        // Может быть множество строк, а не только одна
        cout << "Переменная равна 56" << endl;
        break; // Указываем конец для кода для этой проверки
        // По аналогии таких проверок может быть множество
        // Также можно добавить проверку, которая сработает в случае
        // если все остальные проверки не сработают
    default:
        cout << "Что-то другое" << endl;
        break; // Можно и не ставить, так как это последние условие
}
```


Операторы && и || ведут себя лениво: если первого аргумента уже достаточно для ответа, то второй аргумент вычисляться не будет
Например, в выражении condition1 && condition2 второе условие не вычисляется, если первое ложно



Сравнение чисел с плавающей точкой
Рассмотрим программу, которая проверяет равенство 0.1 + 0.2 == 0.3:

```cpp
#include <iostream>

int main() {
    double x = 0.1, y = 0.2;
    if (x + y == 0.3) {
        std::cout << "EQUAL ";
    } else {
        std::cout << "NOT EQUAL ";
    }

    std::cout << x + y << "\n";
}
```

Логично было бы предположить, что программа выведет EQUAL 0.3
Однако программа напечатает NOT EQUAL 0.3
Данная «ошибка вычисления» встречается в большинстве современных языков программирования и обусловлена погрешностью представления этих чисел
Если повысить число знаков дробной части в выводе, мы увидим, что 0.1 + 0.2 == 0.30000000000000004

Поскольку операции над числами с плавающей точкой могут содержать погрешность, обычное сравнение через == некорректно
Поэтому правильнее сравнивать модуль разности величин с некой допустимой для нас погрешностью
Модуль дробного числа можно получить с помощью функции std::abs из заголовочного файла cmath
Исходную программу можно было бы переписать так

```cpp
#include <cmath>
#include <iostream>

int main() {
    double delta = 0.000001;

    double x = 0.1, y = 0.2;
    double sum = x + y;

    if (std::abs(sum - 0.3) < delta) {
        std::cout << "EQUAL ";
    } else {
        std::cout << "NOT EQUAL ";
    }

    std::cout << sum << "\n";
}
// Теперь программа выведет EQUAL 0.3.
```
