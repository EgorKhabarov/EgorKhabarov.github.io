
# Sort

[ссылка](https://github.com/amaargiru/pycore/blob/main/08_algorithms.ipynb)

| Сортировка                                                              | Преимущество                                                                                           | Best     | Avg      | Worst    | Mem           | Stable          | Paral |
|-------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------|----------|----------|----------|---------------|-----------------|-------|
| [Пузырьковая (Bubble)](?Snippets/Python/Algorithms/Sort/BubbleSort)     | Простейшая реализация                                                                                  | `n`      | `n^2`    | `n^2`    | `1`           | `+`             | `+`   |
| [Быстрая (Quick)](?Snippets/Python/Algorithms/Sort/QuickSort)           | Хорошее быстродействие в среднем случае                                                                | `n*logn` | `n*logn` | `n^2`    | `logn`        | `+/- (depends)` | `+`   |
| [Слиянием (Merge)](?Snippets/Python/Algorithms/Sort/MergeSort)          | Может работать со структурами, к которым возможен только<br>последовательный доступ                    | `n*logn` | `n*logn` | `n*logn` | `n (depends)` | `+`             | `+`   |
| [Пирамидальная (Heap)](?Snippets/Python/Algorithms/Sort/HeapSort)       | Предсказуемая производительность в наихудшем случае,<br>рекомендуется для почти отсортированных данных | `n*logn` | `n*logn` | `n*logn` | `1`           | `-`             | `-`   |
| [Вставками (Insertion)](?Snippets/Python/Algorithms/Sort/InsertionSort) | Рекомендуется для почти отсортированных данных или для<br>малого количества элементов                  | `n`      | `n^2`    | `n^2`    | `1`           | `+`             | `-`   |
| [Timsort](?Snippets/Python/Algorithms/Sort/Timsort)                     | Комбинированный алгоритм.<br>Стандарт для `Python`, `Java`, `Swift`                                    | `n*logn` | `n*logn` | `n*logn` | `logn`        | `-`             | `-`   |
| [Introsort](?Snippets/Python/Algorithms/Sort/Introsort)                 | Комбинированный алгоритм.<br>Стандарт для `.Net`                                                       | `n*logn` | `n*logn` | `n*logn` | `logn`        | `-`             | `-`   |
| [Поразрядная (Radix)](?Snippets/Python/Algorithms/Sort/RadixSort)       | Быстрая сортировка для целых чисел и строк                                                             | `n*w`    | `n*w`    | `n*w`    | `n+w`         | `+/- (depends)` | `+`   |

# Search

| Вид поиска                                                                            | Структура данных       | Avg         | Worst       | Mem |
|---------------------------------------------------------------------------------------|------------------------|-------------|-------------|-----|
| [Линейный поиск](?Snippets/Python/Algorithms/Search/LinearSearch)                     | Массив                 | `n`         | `n`         | `1` |
| [Бинарный поиск](?Snippets/Python/Algorithms/Search/BinarySearch)                     | Отсортированный массив | `logn`      | `n`         | `1` |
| [Поиск в глубину (DFS)](?Snippets/Python/Algorithms/Search/DFS)                       | Граф                   |             | `V+E`       | `V` |
| [Поиск в ширину (BFS)](?Snippets/Python/Algorithms/Search/BFS)                        | Граф                   |             | `V+E`       | `V` |
| [Алгоритм Дейкстры](?Snippets/Python/Algorithms/Search/DijkstrasAlgorithm)            | Граф                   | `(V+E)logV` | `(V+E)logV` | `V` |
| [Алгоритм Беллмана-Форда](?Snippets/Python/Algorithms/Search/Алгоритм Беллмана-Форда) | Граф                   | `V*E`       | `V*E`       | `V` |

# Сравнение структур представления графов

| Метод                                                                                                                    | Mem   | Add V | Add E | Remove V | Remove E | Проверка смежн. V |
|--------------------------------------------------------------------------------------------------------------------------|-------|-------|-------|----------|----------|-------------------|
| [Матрица смежности (Adjacency matrix)](?Snippets/Python/Algorithms/Graph Representation Structures/Adjacency matrix)     | `V^2` | `V^2` | `1`   | `V^2`    | `1`      | `1`               |
| [Матрица инцидентности (Incidence matrix)](?Snippets/Python/Algorithms/Graph Representation Structures/Incidence matrix) | `V*E` | `V*E` | `V*E` | `V*E`    | `V*E`    | `E`               |
| [Список смежности (Adjacency list)](?Snippets/Python/Algorithms/Graph Representation Structures/Adjacency list)          | `V+E` | `1`   | `1`   | `V+E`    | `E`      | `V`               |
| [Список инцидентности (Incidence list)](?Snippets/Python/Algorithms/Graph Representation Structures/Incidence list)      | `V+E` | `1`   | `1`   | `E`      | `E`      | `E`               |


# P vs NP
Задачи класса `P` - реально вычислимые задачи ([тезис Кобэма](https://en.wikipedia.org/wiki/Cobham%27s_thesis)), решаются за полиномиальное время
`NP`-полные задачи - не разрешимы за полиномиальное время,
но могут быть сведены к задачам разрешимости (да/нет),
которые, в свою очередь, решаются за полиномиальное время

# Разделяй и властвуй
Разделяй и властвуй (divide and conquer) - способ решения сложных задач путём рекурсивного разбиения решаемой задачи на две или более подзадачи того же типа,
но меньшего размера, и комбинировании их решений для получения ответа к исходной задаче;
разбиения выполняются до тех пор, пока все подзадачи не окажутся элементарными

# Динамическое программирование
Динамическое программирование - способ решения сложных задач путём разбиения их на более простые подзадачи.
Он применим к задачам со структурой, выглядящей как набор перекрывающихся подзадач, сложность которых меньше исходной.
Ключевая идея: как правило, чтобы решить поставленную задачу, требуется решить отдельные части задачи (подзадачи),\
после чего объединить решения подзадач в одно общее решение
Часто многие из этих подзадач одинаковы
Подход динамического программирования состоит в том, чтобы решить каждую подзадачу только один раз, сократив тем самым количество вычислений
Это особенно полезно в случаях, когда число повторяющихся подзадач экспоненциально велико

# Жадные алгоритмы
Жадный алгоритм (greedy algorithm) - алгоритм, который на каждом шагу делает локально наилучший выбор в надежде, что итоговое решение будет оптимальным

- Как определить, даст ли жадный алгоритм оптимальное решение?
В соответствии с теоремой Радо-Эдмондса, если система является [матроидом](http://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%BE%D0%B8%D0%B4), то для произвольной весовой функции градиентный алгоритм всегда находит точное решение задачи.
Следовательно, если доказать, что объект является матроидом, то жадный алгоритм будет выдавать оптимальный вариант

Жадные алгоритмы проще и быстрее алгоритмов на базе динамического программирования

Различие между жадными алгоритмами и динамическим программированием можно пояснить так:
на каждом шаге жадный алгоритм берет "самый жирный кусок", а потом уже пытается сделать наилучший выбор среди оставшихся,
каковы бы они ни были; алгоритм динамического программирования принимает решение, просчитав заранее последствия для всех вариантов

# Рекурсия
Рекурсия – определение функции через саму себя
Логика рекурсивной функции как правило состоит из двух ветвей
Длинная ветвь вызывает эту же функцию с другими параметрами, чтобы накопить результат
Короткая ветвь определяет критерий выхода из рекурсии

Рекурсия упрощает код и делает его декларативным
Рекурсия поощряет мыслить функционально и избегать побочных эффектов

Неоптимизированная рекурсия приводит к накладным расходам ресурсов
При большом количестве итераций можно превысить лимит на число рекурсивных вызовов (recursion depth limit reached)

# Хвостовая рекурсия
Особый вид рекурсии, когда функция заканчивается вызовом самой себя без дополнительных операторов
Когда это условие выполняется, компилятор разворачивает рекурсию в цикл с одним стек-фреймом,
просто меняя локальные переменные от итерации к итерации

Так, классическое определение рекурсивного факториала `return N * fact(N - 1)` не поддерживает хвостовую рекурсию,
потому что для каждого стек-фрейма придется хранить текущее значение N

Чтобы сделать рекурсии хвостовой, добавляют параметры-аккумуляторы
Благодаря им функция знает о своем текущем состоянии
Пусть параметр `acc` по умолчанию равен `1`
Тогда запись с хвостовой рекурсией будет выглядеть так:
```python
def fact(n, acc=1):
    if n == 1:
        return acc
    else:
        return fact(n - 1, acc * n)
```

## Самые распространенные методы решения задач Leetcode

- Метод скользящего окна (Sliding Window)
- Метод двух указателей (Two Pointers)
- [Нахождение цикла](https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%85%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D1%86%D0%B8%D0%BA%D0%BB%D0%B0) (Fast & Slow Pointers)
- Интервальное слияние (Merge Intervals)
- Цикличная сортировка (Cyclic Sort)
- In-place Reversal для LinkedList (In-place Reversal of a LinkedList)
- [Поиск в ширину](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D1%88%D0%B8%D1%80%D0%B8%D0%BD%D1%83) (Tree Breadth-First Search)
- [Поиск в глубину](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83) (Tree Depth First Search)
- Две кучи (Two Heaps)
- Подмножества (Subsets)
- Модифицированный бинарный поиск (Modified Binary Search)
- Побитовое исключающее ИЛИ (Bitwise XOR)
- Наибольшие K элементов (Top K Elements)
- K-образное слияние (K-way Merge)
- Задача о рюкзаке 0-1 (0/1 Knapsack)
- Задача о неограниченном рюкзаке (Unbounded Knapsack)
- Числа Фибоначчи (Fibonacci Numbers)
- Наибольшая последовательность-палиндром (Palindromic Subsequence)
- Наибольшая общая подстрока (Longest Common Substring)
- Топологическая сортировка (Topological Sort)
- Чтение префиксного дерева (Trie Traversal)
- Количество островов в матрице (Number of Island)
- Метод проб и ошибок (Trial & Error)
- Система непересекающихся множеств (Union Find)
- Задача: найти уникальные маршруты (Unique Paths)


